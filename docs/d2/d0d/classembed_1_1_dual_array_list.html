<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>embed: embed::DualArrayList&lt; T, N &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">embed
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d0d/classembed_1_1_dual_array_list.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d0/d8a/classembed_1_1_dual_array_list-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">embed::DualArrayList&lt; T, N &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Two ArrayLists that share the same memory buffer.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../dc/df2/_dual_array_list_8hpp_source.html">DualArrayList.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adce44ad0a4e78db5e1f33fb50f397bd2" id="r_adce44ad0a4e78db5e1f33fb50f397bd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adce44ad0a4e78db5e1f33fb50f397bd2">value_type</a> = T</td></tr>
<tr class="separator:adce44ad0a4e78db5e1f33fb50f397bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71977d37caaecbc4e1891156aa543320" id="r_a71977d37caaecbc4e1891156aa543320"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> = std::size_t</td></tr>
<tr class="separator:a71977d37caaecbc4e1891156aa543320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208c2fd2b3bb1bea13c4ace4f6b46e2" id="r_ad208c2fd2b3bb1bea13c4ace4f6b46e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> = T&amp;</td></tr>
<tr class="separator:ad208c2fd2b3bb1bea13c4ace4f6b46e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6596356aa4feae74ca1e917e294974fd" id="r_a6596356aa4feae74ca1e917e294974fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> = const T&amp;</td></tr>
<tr class="separator:a6596356aa4feae74ca1e917e294974fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c0953f0ba924018b30d45adb3eb314" id="r_ae9c0953f0ba924018b30d45adb3eb314"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c0953f0ba924018b30d45adb3eb314">pointer</a> = T*</td></tr>
<tr class="separator:ae9c0953f0ba924018b30d45adb3eb314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935997e01da73cafa167c9ad8f61f5d2" id="r_a935997e01da73cafa167c9ad8f61f5d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935997e01da73cafa167c9ad8f61f5d2">const_pointer</a> = const T*</td></tr>
<tr class="separator:a935997e01da73cafa167c9ad8f61f5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89dde5db095f00a6dc761971650bc9b" id="r_ac89dde5db095f00a6dc761971650bc9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> = T*</td></tr>
<tr class="separator:ac89dde5db095f00a6dc761971650bc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a067a56a615290d906bd4e69ff5f05" id="r_a15a067a56a615290d906bd4e69ff5f05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> = const T*</td></tr>
<tr class="separator:a15a067a56a615290d906bd4e69ff5f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1bc61a3e37397bcaf33fa9693bd634" id="r_a5f1bc61a3e37397bcaf33fa9693bd634"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> = std::reverse_iterator&lt;<a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&gt;</td></tr>
<tr class="separator:a5f1bc61a3e37397bcaf33fa9693bd634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f50229b64f2699d274c5e134a36ef" id="r_a170f50229b64f2699d274c5e134a36ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> = std::reverse_iterator&lt;<a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&gt;</td></tr>
<tr class="separator:a170f50229b64f2699d274c5e134a36ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef3178a70c9216f06dec4522c29f8ac" id="r_a0ef3178a70c9216f06dec4522c29f8ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ef3178a70c9216f06dec4522c29f8ac">left_range</a> = std::ranges::subrange&lt;<a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&gt;</td></tr>
<tr class="separator:a0ef3178a70c9216f06dec4522c29f8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3792e2f18c3165b9c58e4dfcb906a37d" id="r_a3792e2f18c3165b9c58e4dfcb906a37d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3792e2f18c3165b9c58e4dfcb906a37d">left_const_range</a> = std::ranges::subrange&lt;<a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&gt;</td></tr>
<tr class="separator:a3792e2f18c3165b9c58e4dfcb906a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add39ffc0a861261fe003a1c993cbd700" id="r_add39ffc0a861261fe003a1c993cbd700"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add39ffc0a861261fe003a1c993cbd700">right_range</a> = std::ranges::subrange&lt;<a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&gt;</td></tr>
<tr class="separator:add39ffc0a861261fe003a1c993cbd700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039279bf390b9c10a3a960c1f3c51ac" id="r_a7039279bf390b9c10a3a960c1f3c51ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7039279bf390b9c10a3a960c1f3c51ac">right_const_range</a> = std::ranges::subrange&lt;<a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&gt;</td></tr>
<tr class="separator:a7039279bf390b9c10a3a960c1f3c51ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8fed78f7d3b0e439a21eb146d085846" id="r_ae8fed78f7d3b0e439a21eb146d085846"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8fed78f7d3b0e439a21eb146d085846">DualArrayList</a> ()=default</td></tr>
<tr class="memdesc:ae8fed78f7d3b0e439a21eb146d085846"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructs two empty lists  <br /></td></tr>
<tr class="separator:ae8fed78f7d3b0e439a21eb146d085846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a18fc02231154874bbe0465e0a68ca" id="r_aa7a18fc02231154874bbe0465e0a68ca"><td class="memTemplParams" colspan="2">template&lt;size_t N1&gt; </td></tr>
<tr class="memitem:aa7a18fc02231154874bbe0465e0a68ca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7a18fc02231154874bbe0465e0a68ca">DualArrayList</a> (const <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a>&lt; T, N1 &gt; &amp;other)</td></tr>
<tr class="memdesc:aa7a18fc02231154874bbe0465e0a68ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs both lists like from the other dual list.  <br /></td></tr>
<tr class="separator:aa7a18fc02231154874bbe0465e0a68ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c47c4c81cd9f7e47fce788108aee44" id="r_ad4c47c4c81cd9f7e47fce788108aee44"><td class="memTemplParams" colspan="2">template&lt;size_t N1&gt; </td></tr>
<tr class="memitem:ad4c47c4c81cd9f7e47fce788108aee44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4c47c4c81cd9f7e47fce788108aee44">operator=</a> (const <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a>&lt; T, N1 &gt; &amp;other)</td></tr>
<tr class="memdesc:ad4c47c4c81cd9f7e47fce788108aee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns both lists like from the other dual list.  <br /></td></tr>
<tr class="separator:ad4c47c4c81cd9f7e47fce788108aee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f14d57f718b42f68c52d66c380b3ed3" id="r_a9f14d57f718b42f68c52d66c380b3ed3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f14d57f718b42f68c52d66c380b3ed3">left_size</a> () const</td></tr>
<tr class="memdesc:a9f14d57f718b42f68c52d66c380b3ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the left list.  <br /></td></tr>
<tr class="separator:a9f14d57f718b42f68c52d66c380b3ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dac9de8e2b912fbc0a9663685361e7" id="r_a99dac9de8e2b912fbc0a9663685361e7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99dac9de8e2b912fbc0a9663685361e7">right_size</a> () const</td></tr>
<tr class="memdesc:a99dac9de8e2b912fbc0a9663685361e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the right list.  <br /></td></tr>
<tr class="separator:a99dac9de8e2b912fbc0a9663685361e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac140b762cceebd1a30d724eca0415834" id="r_ac140b762cceebd1a30d724eca0415834"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac140b762cceebd1a30d724eca0415834">size</a> () const</td></tr>
<tr class="memdesc:ac140b762cceebd1a30d724eca0415834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the combined size of both lists.  <br /></td></tr>
<tr class="separator:ac140b762cceebd1a30d724eca0415834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2981c9e684e0d4f0d77e045d4a40be" id="r_a1e2981c9e684e0d4f0d77e045d4a40be"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e2981c9e684e0d4f0d77e045d4a40be">max_size</a> () const</td></tr>
<tr class="memdesc:a1e2981c9e684e0d4f0d77e045d4a40be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal size - is the same for left and right.  <br /></td></tr>
<tr class="separator:a1e2981c9e684e0d4f0d77e045d4a40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eb05a9d31e9bf290670dd116c22835" id="r_a02eb05a9d31e9bf290670dd116c22835"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02eb05a9d31e9bf290670dd116c22835">left_capacity</a> () const</td></tr>
<tr class="memdesc:a02eb05a9d31e9bf290670dd116c22835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the left list.  <br /></td></tr>
<tr class="separator:a02eb05a9d31e9bf290670dd116c22835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d6767bc0dcf782ce8d43408ab9802d" id="r_a35d6767bc0dcf782ce8d43408ab9802d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35d6767bc0dcf782ce8d43408ab9802d">right_capacity</a> () const</td></tr>
<tr class="memdesc:a35d6767bc0dcf782ce8d43408ab9802d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the right list.  <br /></td></tr>
<tr class="separator:a35d6767bc0dcf782ce8d43408ab9802d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb515edd16f1c1202d38e10c4d42e703" id="r_acb515edd16f1c1202d38e10c4d42e703"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb515edd16f1c1202d38e10c4d42e703">reserve</a> () const</td></tr>
<tr class="memdesc:acb515edd16f1c1202d38e10c4d42e703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the reserve (aka.) number of free elements that has not been claimed by either list.  <br /></td></tr>
<tr class="separator:acb515edd16f1c1202d38e10c4d42e703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e0b2ca1fb4423aa91d59dfbf15b437" id="r_ab0e0b2ca1fb4423aa91d59dfbf15b437"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e0b2ca1fb4423aa91d59dfbf15b437">left_empty</a> () const</td></tr>
<tr class="memdesc:ab0e0b2ca1fb4423aa91d59dfbf15b437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the left list is empty.  <br /></td></tr>
<tr class="separator:ab0e0b2ca1fb4423aa91d59dfbf15b437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fee93036f6b38d0c9abd99650fe8e6" id="r_ab3fee93036f6b38d0c9abd99650fe8e6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3fee93036f6b38d0c9abd99650fe8e6">right_empty</a> () const</td></tr>
<tr class="memdesc:ab3fee93036f6b38d0c9abd99650fe8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if the right list is empty  <br /></td></tr>
<tr class="separator:ab3fee93036f6b38d0c9abd99650fe8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f7ca1063dad1fb64d95d24337a3134" id="r_ac1f7ca1063dad1fb64d95d24337a3134"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f7ca1063dad1fb64d95d24337a3134">empty</a> () const</td></tr>
<tr class="memdesc:ac1f7ca1063dad1fb64d95d24337a3134"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both lists are empty  <br /></td></tr>
<tr class="separator:ac1f7ca1063dad1fb64d95d24337a3134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b4aa5ae48be18369a6f6a37bd75dfb" id="r_af1b4aa5ae48be18369a6f6a37bd75dfb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1b4aa5ae48be18369a6f6a37bd75dfb">full</a> () const</td></tr>
<tr class="memdesc:af1b4aa5ae48be18369a6f6a37bd75dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if the lists are full, all elements have been taken by either side, no more elements can be emplaced.  <br /></td></tr>
<tr class="separator:af1b4aa5ae48be18369a6f6a37bd75dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421f7ae6cfd90c8f9e46916e170e55c4" id="r_a421f7ae6cfd90c8f9e46916e170e55c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ae9c0953f0ba924018b30d45adb3eb314">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a421f7ae6cfd90c8f9e46916e170e55c4">data</a> ()</td></tr>
<tr class="separator:a421f7ae6cfd90c8f9e46916e170e55c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e1b2744b2edcceb423439e52aab79b" id="r_ae3e1b2744b2edcceb423439e52aab79b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a935997e01da73cafa167c9ad8f61f5d2">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e1b2744b2edcceb423439e52aab79b">data</a> () const</td></tr>
<tr class="separator:ae3e1b2744b2edcceb423439e52aab79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad937788ca0b51a7825e19d5610fc5f" id="r_a8ad937788ca0b51a7825e19d5610fc5f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a935997e01da73cafa167c9ad8f61f5d2">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad937788ca0b51a7825e19d5610fc5f">cdata</a> () const</td></tr>
<tr class="separator:a8ad937788ca0b51a7825e19d5610fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43bc88a2f2b518d5d9ee8272fb71cd8" id="r_ac43bc88a2f2b518d5d9ee8272fb71cd8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac43bc88a2f2b518d5d9ee8272fb71cd8">left_begin</a> ()</td></tr>
<tr class="memdesc:ac43bc88a2f2b518d5d9ee8272fb71cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the beginning of the left list  <br /></td></tr>
<tr class="separator:ac43bc88a2f2b518d5d9ee8272fb71cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a29e6bd57819aef0f0b3049cd16fefd" id="r_a1a29e6bd57819aef0f0b3049cd16fefd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a29e6bd57819aef0f0b3049cd16fefd">left_begin</a> () const</td></tr>
<tr class="memdesc:a1a29e6bd57819aef0f0b3049cd16fefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1a29e6bd57819aef0f0b3049cd16fefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38287399f78a40c9488cd779a81c1854" id="r_a38287399f78a40c9488cd779a81c1854"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38287399f78a40c9488cd779a81c1854">left_cbegin</a> () const</td></tr>
<tr class="memdesc:a38287399f78a40c9488cd779a81c1854"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a38287399f78a40c9488cd779a81c1854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb44b15aec97d9e542b3fada7a2d84" id="r_a87fb44b15aec97d9e542b3fada7a2d84"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87fb44b15aec97d9e542b3fada7a2d84">right_begin</a> ()</td></tr>
<tr class="memdesc:a87fb44b15aec97d9e542b3fada7a2d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator ot the beginning of the right list  <br /></td></tr>
<tr class="separator:a87fb44b15aec97d9e542b3fada7a2d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add65c3292703f42aff3b1909a9dbae6a" id="r_add65c3292703f42aff3b1909a9dbae6a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add65c3292703f42aff3b1909a9dbae6a">right_begin</a> () const</td></tr>
<tr class="memdesc:add65c3292703f42aff3b1909a9dbae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:add65c3292703f42aff3b1909a9dbae6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2131ba51e6fbec775659e7dfa517a4" id="r_afd2131ba51e6fbec775659e7dfa517a4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd2131ba51e6fbec775659e7dfa517a4">right_cbegin</a> () const</td></tr>
<tr class="memdesc:afd2131ba51e6fbec775659e7dfa517a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:afd2131ba51e6fbec775659e7dfa517a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de51e9472d360069c54be26b983a6ec" id="r_a5de51e9472d360069c54be26b983a6ec"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5de51e9472d360069c54be26b983a6ec">left_end</a> ()</td></tr>
<tr class="memdesc:a5de51e9472d360069c54be26b983a6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator past the end of the left list  <br /></td></tr>
<tr class="separator:a5de51e9472d360069c54be26b983a6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c22b4ccebb8cc460e7c710f84e7a1fd" id="r_a1c22b4ccebb8cc460e7c710f84e7a1fd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c22b4ccebb8cc460e7c710f84e7a1fd">left_end</a> () const</td></tr>
<tr class="memdesc:a1c22b4ccebb8cc460e7c710f84e7a1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1c22b4ccebb8cc460e7c710f84e7a1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a576f9836ea744463c948330cfc95" id="r_a2a6a576f9836ea744463c948330cfc95"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6a576f9836ea744463c948330cfc95">left_cend</a> () const</td></tr>
<tr class="memdesc:a2a6a576f9836ea744463c948330cfc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2a6a576f9836ea744463c948330cfc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5075261f249ce574783184abce8471" id="r_a9c5075261f249ce574783184abce8471"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5075261f249ce574783184abce8471">right_end</a> ()</td></tr>
<tr class="memdesc:a9c5075261f249ce574783184abce8471"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator past the end of the right list  <br /></td></tr>
<tr class="separator:a9c5075261f249ce574783184abce8471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1603d1521c10c23a53ae997dd43bff" id="r_aae1603d1521c10c23a53ae997dd43bff"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae1603d1521c10c23a53ae997dd43bff">right_end</a> () const</td></tr>
<tr class="memdesc:aae1603d1521c10c23a53ae997dd43bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aae1603d1521c10c23a53ae997dd43bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f098b97fbfea8431565f54cdf3144d5" id="r_a3f098b97fbfea8431565f54cdf3144d5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f098b97fbfea8431565f54cdf3144d5">right_cend</a> () const</td></tr>
<tr class="memdesc:a3f098b97fbfea8431565f54cdf3144d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3f098b97fbfea8431565f54cdf3144d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb231b2c614bffa79244d14935036ce" id="r_a4cb231b2c614bffa79244d14935036ce"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a0ef3178a70c9216f06dec4522c29f8ac">left_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb231b2c614bffa79244d14935036ce">left_subrange</a> ()</td></tr>
<tr class="memdesc:a4cb231b2c614bffa79244d14935036ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the left list as a subrange  <br /></td></tr>
<tr class="separator:a4cb231b2c614bffa79244d14935036ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2767dc5c7899e068eff50cfe8d844a12" id="r_a2767dc5c7899e068eff50cfe8d844a12"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a3792e2f18c3165b9c58e4dfcb906a37d">left_const_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2767dc5c7899e068eff50cfe8d844a12">left_subrange</a> () const</td></tr>
<tr class="memdesc:a2767dc5c7899e068eff50cfe8d844a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2767dc5c7899e068eff50cfe8d844a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81453a1ac2df981e962a7e5625e66716" id="r_a81453a1ac2df981e962a7e5625e66716"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a3792e2f18c3165b9c58e4dfcb906a37d">left_const_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81453a1ac2df981e962a7e5625e66716">left_csubrange</a> () const</td></tr>
<tr class="memdesc:a81453a1ac2df981e962a7e5625e66716"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a81453a1ac2df981e962a7e5625e66716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9415955d6deb2ecc704647a58769ff6" id="r_ac9415955d6deb2ecc704647a58769ff6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#add39ffc0a861261fe003a1c993cbd700">right_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9415955d6deb2ecc704647a58769ff6">right_subrange</a> ()</td></tr>
<tr class="memdesc:ac9415955d6deb2ecc704647a58769ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the right list as a subrange  <br /></td></tr>
<tr class="separator:ac9415955d6deb2ecc704647a58769ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b95f3da04ef4f86cb61399924f2eeb" id="r_a67b95f3da04ef4f86cb61399924f2eeb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a7039279bf390b9c10a3a960c1f3c51ac">right_const_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67b95f3da04ef4f86cb61399924f2eeb">right_subrange</a> () const</td></tr>
<tr class="memdesc:a67b95f3da04ef4f86cb61399924f2eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a67b95f3da04ef4f86cb61399924f2eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add81037e7aa98d68695311fe74f61a1c" id="r_add81037e7aa98d68695311fe74f61a1c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a7039279bf390b9c10a3a960c1f3c51ac">right_const_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add81037e7aa98d68695311fe74f61a1c">right_csubrange</a> () const</td></tr>
<tr class="memdesc:add81037e7aa98d68695311fe74f61a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:add81037e7aa98d68695311fe74f61a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac1a43931c5f4a8c59895f7cdc71063" id="r_a4ac1a43931c5f4a8c59895f7cdc71063"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ac1a43931c5f4a8c59895f7cdc71063">left_front</a> ()</td></tr>
<tr class="memdesc:a4ac1a43931c5f4a8c59895f7cdc71063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the first element in the left list.  <br /></td></tr>
<tr class="separator:a4ac1a43931c5f4a8c59895f7cdc71063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3853c4886f59ca621c994a30eeff2640" id="r_a3853c4886f59ca621c994a30eeff2640"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3853c4886f59ca621c994a30eeff2640">left_front</a> () const</td></tr>
<tr class="memdesc:a3853c4886f59ca621c994a30eeff2640"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3853c4886f59ca621c994a30eeff2640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a50ea1126c5e6106291f2dadbdbc80" id="r_ac3a50ea1126c5e6106291f2dadbdbc80"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3a50ea1126c5e6106291f2dadbdbc80">left_back</a> ()</td></tr>
<tr class="memdesc:ac3a50ea1126c5e6106291f2dadbdbc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the last element in the left list.  <br /></td></tr>
<tr class="separator:ac3a50ea1126c5e6106291f2dadbdbc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57b841f5060c5d84ff32179df4c1f59" id="r_ac57b841f5060c5d84ff32179df4c1f59"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac57b841f5060c5d84ff32179df4c1f59">left_back</a> () const</td></tr>
<tr class="memdesc:ac57b841f5060c5d84ff32179df4c1f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac57b841f5060c5d84ff32179df4c1f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3927a687ef3a1786d8ab81a38d5043" id="r_a0f3927a687ef3a1786d8ab81a38d5043"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3927a687ef3a1786d8ab81a38d5043">right_front</a> ()</td></tr>
<tr class="memdesc:a0f3927a687ef3a1786d8ab81a38d5043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the first element in the right list.  <br /></td></tr>
<tr class="separator:a0f3927a687ef3a1786d8ab81a38d5043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0fe67127c70cecd01ef07fd43b3f5c" id="r_aba0fe67127c70cecd01ef07fd43b3f5c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba0fe67127c70cecd01ef07fd43b3f5c">right_front</a> () const</td></tr>
<tr class="memdesc:aba0fe67127c70cecd01ef07fd43b3f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aba0fe67127c70cecd01ef07fd43b3f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b40ff8ffe5030c67882fea38d4692" id="r_a923b40ff8ffe5030c67882fea38d4692"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923b40ff8ffe5030c67882fea38d4692">right_back</a> ()</td></tr>
<tr class="memdesc:a923b40ff8ffe5030c67882fea38d4692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference of the last element in the right list.  <br /></td></tr>
<tr class="separator:a923b40ff8ffe5030c67882fea38d4692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415aadf1cbb8d93505ae81847caf84d6" id="r_a415aadf1cbb8d93505ae81847caf84d6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415aadf1cbb8d93505ae81847caf84d6">right_back</a> () const</td></tr>
<tr class="memdesc:a415aadf1cbb8d93505ae81847caf84d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a415aadf1cbb8d93505ae81847caf84d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6229164dacca6fc433edbe3c3e3cd7d8" id="r_a6229164dacca6fc433edbe3c3e3cd7d8"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a6229164dacca6fc433edbe3c3e3cd7d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6229164dacca6fc433edbe3c3e3cd7d8">left_at</a> (const UInt i)</td></tr>
<tr class="memdesc:a6229164dacca6fc433edbe3c3e3cd7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element in the left list at the position with the given index.  <br /></td></tr>
<tr class="separator:a6229164dacca6fc433edbe3c3e3cd7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb8e12a7f1b412ad6673a7cca716601" id="r_a7fb8e12a7f1b412ad6673a7cca716601"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a7fb8e12a7f1b412ad6673a7cca716601"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fb8e12a7f1b412ad6673a7cca716601">left_at</a> (const UInt i) const</td></tr>
<tr class="memdesc:a7fb8e12a7f1b412ad6673a7cca716601"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7fb8e12a7f1b412ad6673a7cca716601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0e454c9b51ad30be90e3f5e61ddb9f" id="r_a8f0e454c9b51ad30be90e3f5e61ddb9f"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a8f0e454c9b51ad30be90e3f5e61ddb9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f0e454c9b51ad30be90e3f5e61ddb9f">right_at</a> (const UInt i)</td></tr>
<tr class="memdesc:a8f0e454c9b51ad30be90e3f5e61ddb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element in the right list at the position with the given index.  <br /></td></tr>
<tr class="separator:a8f0e454c9b51ad30be90e3f5e61ddb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7635148eefc0dc1130260e31f8e4ea" id="r_aef7635148eefc0dc1130260e31f8e4ea"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:aef7635148eefc0dc1130260e31f8e4ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef7635148eefc0dc1130260e31f8e4ea">right_at</a> (const UInt i) const</td></tr>
<tr class="memdesc:aef7635148eefc0dc1130260e31f8e4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aef7635148eefc0dc1130260e31f8e4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a92ed69ee2c73a4dd43b2545eab7bd4" id="r_a0a92ed69ee2c73a4dd43b2545eab7bd4"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:a0a92ed69ee2c73a4dd43b2545eab7bd4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a92ed69ee2c73a4dd43b2545eab7bd4">left_at</a> (SInt si)</td></tr>
<tr class="memdesc:a0a92ed69ee2c73a4dd43b2545eab7bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element in the left list at the wrapped position with the given index.  <br /></td></tr>
<tr class="separator:a0a92ed69ee2c73a4dd43b2545eab7bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20f94575b2009725139a655b081ce6e" id="r_ab20f94575b2009725139a655b081ce6e"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:ab20f94575b2009725139a655b081ce6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab20f94575b2009725139a655b081ce6e">left_at</a> (const SInt si) const</td></tr>
<tr class="memdesc:ab20f94575b2009725139a655b081ce6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab20f94575b2009725139a655b081ce6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83542a8d008dc3f38956dc8dd92cb3e" id="r_ab83542a8d008dc3f38956dc8dd92cb3e"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:ab83542a8d008dc3f38956dc8dd92cb3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab83542a8d008dc3f38956dc8dd92cb3e">right_at</a> (SInt si)</td></tr>
<tr class="memdesc:ab83542a8d008dc3f38956dc8dd92cb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element in the right list at the wrapped position with the given index.  <br /></td></tr>
<tr class="separator:ab83542a8d008dc3f38956dc8dd92cb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab245dbf54facb89c1f2029ea579b24dc" id="r_ab245dbf54facb89c1f2029ea579b24dc"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:ab245dbf54facb89c1f2029ea579b24dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab245dbf54facb89c1f2029ea579b24dc">right_at</a> (const SInt si) const</td></tr>
<tr class="memdesc:ab245dbf54facb89c1f2029ea579b24dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab245dbf54facb89c1f2029ea579b24dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55dad8520bc874b98612177038f8a03" id="r_ad55dad8520bc874b98612177038f8a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad55dad8520bc874b98612177038f8a03">left_at</a> (const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; bool, N &gt; &amp;mask) const</td></tr>
<tr class="memdesc:ad55dad8520bc874b98612177038f8a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked indexing of the left list.  <br /></td></tr>
<tr class="separator:ad55dad8520bc874b98612177038f8a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a199b1fa4905c7ef690a97dbdcd50fe" id="r_a6a199b1fa4905c7ef690a97dbdcd50fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a199b1fa4905c7ef690a97dbdcd50fe">right_at</a> (const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; bool, N &gt; &amp;mask) const</td></tr>
<tr class="memdesc:a6a199b1fa4905c7ef690a97dbdcd50fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masked indexing of the right list.  <br /></td></tr>
<tr class="separator:a6a199b1fa4905c7ef690a97dbdcd50fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05474397e7544ef5e18d31f3069a4a68" id="r_a05474397e7544ef5e18d31f3069a4a68"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a05474397e7544ef5e18d31f3069a4a68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05474397e7544ef5e18d31f3069a4a68">left_at</a> (const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; Int, N &gt; &amp;indices) const</td></tr>
<tr class="memdesc:a05474397e7544ef5e18d31f3069a4a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a list of from the left list at the provided list of indices  <br /></td></tr>
<tr class="separator:a05474397e7544ef5e18d31f3069a4a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac3506ba342076e5fc45a750dd45ff2" id="r_a8ac3506ba342076e5fc45a750dd45ff2"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a8ac3506ba342076e5fc45a750dd45ff2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ac3506ba342076e5fc45a750dd45ff2">right_at</a> (const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; Int, N &gt; &amp;indices) const</td></tr>
<tr class="memdesc:a8ac3506ba342076e5fc45a750dd45ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a list of from the right list at the provided list of indices  <br /></td></tr>
<tr class="separator:a8ac3506ba342076e5fc45a750dd45ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4370e41cc235cd6a70f39ec2b884d1fd" id="r_a4370e41cc235cd6a70f39ec2b884d1fd"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a4370e41cc235cd6a70f39ec2b884d1fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4370e41cc235cd6a70f39ec2b884d1fd">left_emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4370e41cc235cd6a70f39ec2b884d1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">emplaces (aka. pushes) an element to the back of the left list  <br /></td></tr>
<tr class="separator:a4370e41cc235cd6a70f39ec2b884d1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812325107bdb9a4c7062b6cbd29f0ab4" id="r_a812325107bdb9a4c7062b6cbd29f0ab4"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a812325107bdb9a4c7062b6cbd29f0ab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a812325107bdb9a4c7062b6cbd29f0ab4">right_emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a812325107bdb9a4c7062b6cbd29f0ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">emplaces (aka. pushes) an element to the back of the right list  <br /></td></tr>
<tr class="separator:a812325107bdb9a4c7062b6cbd29f0ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a4c3484febf477560276c7ff28d168" id="r_a40a4c3484febf477560276c7ff28d168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a4c3484febf477560276c7ff28d168">left_clear</a> ()</td></tr>
<tr class="memdesc:a40a4c3484febf477560276c7ff28d168"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the left list  <br /></td></tr>
<tr class="separator:a40a4c3484febf477560276c7ff28d168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e547d9a142ec41f5b094ee523262857" id="r_a8e547d9a142ec41f5b094ee523262857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e547d9a142ec41f5b094ee523262857">right_clear</a> ()</td></tr>
<tr class="memdesc:a8e547d9a142ec41f5b094ee523262857"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the right list  <br /></td></tr>
<tr class="separator:a8e547d9a142ec41f5b094ee523262857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c4ed583a0ac535d02d249ad99c5abf" id="r_a85c4ed583a0ac535d02d249ad99c5abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85c4ed583a0ac535d02d249ad99c5abf">clear</a> ()</td></tr>
<tr class="memdesc:a85c4ed583a0ac535d02d249ad99c5abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears both lists  <br /></td></tr>
<tr class="separator:a85c4ed583a0ac535d02d249ad99c5abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac062374be6a7f25cbf10ce9c9ea9879d" id="r_ac062374be6a7f25cbf10ce9c9ea9879d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac062374be6a7f25cbf10ce9c9ea9879d">left_append</a> (const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:ac062374be6a7f25cbf10ce9c9ea9879d"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends <code>value</code> <code>count</code> many times to the left list  <br /></td></tr>
<tr class="separator:ac062374be6a7f25cbf10ce9c9ea9879d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c614a96e095eca11ad6604d73d2b3c" id="r_a74c614a96e095eca11ad6604d73d2b3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74c614a96e095eca11ad6604d73d2b3c">right_append</a> (const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:a74c614a96e095eca11ad6604d73d2b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends <code>value</code> <code>count</code> many times to the right list  <br /></td></tr>
<tr class="separator:a74c614a96e095eca11ad6604d73d2b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0021acdeaadb111aea59d8567f6bdab" id="r_ac0021acdeaadb111aea59d8567f6bdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0021acdeaadb111aea59d8567f6bdab">left_assign</a> (const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:ac0021acdeaadb111aea59d8567f6bdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">assigns a value count many times to the left list.  <br /></td></tr>
<tr class="separator:ac0021acdeaadb111aea59d8567f6bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae22a16cdf93ba59c5ead82c8238ae4" id="r_adae22a16cdf93ba59c5ead82c8238ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae22a16cdf93ba59c5ead82c8238ae4">right_assign</a> (const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> count, const T &amp;value)</td></tr>
<tr class="memdesc:adae22a16cdf93ba59c5ead82c8238ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">assigns a value count many times to the right list.  <br /></td></tr>
<tr class="separator:adae22a16cdf93ba59c5ead82c8238ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac527a8ae30380e7418b2ddb9cdb2037f" id="r_ac527a8ae30380e7418b2ddb9cdb2037f"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator Itr&gt; </td></tr>
<tr class="memitem:ac527a8ae30380e7418b2ddb9cdb2037f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac527a8ae30380e7418b2ddb9cdb2037f">left_append</a> (Itr first, Itr last)</td></tr>
<tr class="memdesc:ac527a8ae30380e7418b2ddb9cdb2037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">appends a range of elements defined by foreward iterators using the closed-open principle [first, last)  <br /></td></tr>
<tr class="separator:ac527a8ae30380e7418b2ddb9cdb2037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051413018ef259965bbd4a6ef16149bc" id="r_a051413018ef259965bbd4a6ef16149bc"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator Itr&gt; </td></tr>
<tr class="memitem:a051413018ef259965bbd4a6ef16149bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a051413018ef259965bbd4a6ef16149bc">right_append</a> (Itr first, Itr last)</td></tr>
<tr class="separator:a051413018ef259965bbd4a6ef16149bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f726632fe4f4f1e35d0ac22f29c284f" id="r_a5f726632fe4f4f1e35d0ac22f29c284f"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator Itr&gt; </td></tr>
<tr class="memitem:a5f726632fe4f4f1e35d0ac22f29c284f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f726632fe4f4f1e35d0ac22f29c284f">left_assign</a> (Itr first, Itr last)</td></tr>
<tr class="separator:a5f726632fe4f4f1e35d0ac22f29c284f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75209e37732ab85a6f0f8edd7e20c236" id="r_a75209e37732ab85a6f0f8edd7e20c236"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator Itr&gt; </td></tr>
<tr class="memitem:a75209e37732ab85a6f0f8edd7e20c236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75209e37732ab85a6f0f8edd7e20c236">right_assign</a> (Itr first, Itr last)</td></tr>
<tr class="separator:a75209e37732ab85a6f0f8edd7e20c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49eaf71db11ae09874ddf28bbe96f65b" id="r_a49eaf71db11ae09874ddf28bbe96f65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49eaf71db11ae09874ddf28bbe96f65b">left_append</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:a49eaf71db11ae09874ddf28bbe96f65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf2c45c9314f6ed1e09d91d9ac0a6d" id="r_a4adf2c45c9314f6ed1e09d91d9ac0a6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4adf2c45c9314f6ed1e09d91d9ac0a6d">right_append</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:a4adf2c45c9314f6ed1e09d91d9ac0a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d1e1ec1b7cbe486c262f4f916119b" id="r_a7a8d1e1ec1b7cbe486c262f4f916119b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a8d1e1ec1b7cbe486c262f4f916119b">left_assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:a7a8d1e1ec1b7cbe486c262f4f916119b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e01e63b08a609fb6d0bcf974a636069" id="r_a1e01e63b08a609fb6d0bcf974a636069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e01e63b08a609fb6d0bcf974a636069">right_assign</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:a1e01e63b08a609fb6d0bcf974a636069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceb56832904a96d391dbbd7c66e4d78" id="r_a4ceb56832904a96d391dbbd7c66e4d78"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range Range&gt; </td></tr>
<tr class="memitem:a4ceb56832904a96d391dbbd7c66e4d78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ceb56832904a96d391dbbd7c66e4d78">left_append</a> (const Range &amp;range)</td></tr>
<tr class="separator:a4ceb56832904a96d391dbbd7c66e4d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ada1a14900858fcec62a1c8a5aeaf20" id="r_a6ada1a14900858fcec62a1c8a5aeaf20"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range Range&gt; </td></tr>
<tr class="memitem:a6ada1a14900858fcec62a1c8a5aeaf20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ada1a14900858fcec62a1c8a5aeaf20">right_append</a> (const Range &amp;range)</td></tr>
<tr class="separator:a6ada1a14900858fcec62a1c8a5aeaf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39e3749e42474053d58ae4df8b85dd4" id="r_af39e3749e42474053d58ae4df8b85dd4"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range Range&gt; </td></tr>
<tr class="memitem:af39e3749e42474053d58ae4df8b85dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af39e3749e42474053d58ae4df8b85dd4">left_assign</a> (const Range &amp;range)</td></tr>
<tr class="separator:af39e3749e42474053d58ae4df8b85dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1214e974a5efe764f00a5b5fe1d44a1" id="r_af1214e974a5efe764f00a5b5fe1d44a1"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range Range&gt; </td></tr>
<tr class="memitem:af1214e974a5efe764f00a5b5fe1d44a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1214e974a5efe764f00a5b5fe1d44a1">right_assign</a> (const Range &amp;range)</td></tr>
<tr class="separator:af1214e974a5efe764f00a5b5fe1d44a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e0c44262fab5d0662840e40b97af43" id="r_a60e0c44262fab5d0662840e40b97af43"><td class="memTemplParams" colspan="2">template&lt;size_t N1&gt; </td></tr>
<tr class="memitem:a60e0c44262fab5d0662840e40b97af43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60e0c44262fab5d0662840e40b97af43">assign</a> (const <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a>&lt; T, N1 &gt; &amp;other)</td></tr>
<tr class="separator:a60e0c44262fab5d0662840e40b97af43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f10fdb21330e8459eb7d1745158b0af" id="r_a3f10fdb21330e8459eb7d1745158b0af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f10fdb21330e8459eb7d1745158b0af">left_to_index</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos) const</td></tr>
<tr class="separator:a3f10fdb21330e8459eb7d1745158b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055862dbe8a9d2dd382e71fe913b33ba" id="r_a055862dbe8a9d2dd382e71fe913b33ba"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a055862dbe8a9d2dd382e71fe913b33ba">right_to_index</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos) const</td></tr>
<tr class="separator:a055862dbe8a9d2dd382e71fe913b33ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880d00cd84e3ae79a8cce84d902b5adc" id="r_a880d00cd84e3ae79a8cce84d902b5adc"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a880d00cd84e3ae79a8cce84d902b5adc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a880d00cd84e3ae79a8cce84d902b5adc">left_to_iterator</a> (const UInt pos)</td></tr>
<tr class="separator:a880d00cd84e3ae79a8cce84d902b5adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3b4932bcd698d1e90568ee9c2d2651" id="r_a4d3b4932bcd698d1e90568ee9c2d2651"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a4d3b4932bcd698d1e90568ee9c2d2651"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d3b4932bcd698d1e90568ee9c2d2651">right_to_iterator</a> (const UInt pos)</td></tr>
<tr class="separator:a4d3b4932bcd698d1e90568ee9c2d2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8468c91808c43eb5d9ae3e7af82d1d38" id="r_a8468c91808c43eb5d9ae3e7af82d1d38"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:a8468c91808c43eb5d9ae3e7af82d1d38"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8468c91808c43eb5d9ae3e7af82d1d38">left_to_iterator</a> (const SInt pos)</td></tr>
<tr class="separator:a8468c91808c43eb5d9ae3e7af82d1d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac16155ab224c07fe4a4b48e94d9389" id="r_a2ac16155ab224c07fe4a4b48e94d9389"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:a2ac16155ab224c07fe4a4b48e94d9389"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ac16155ab224c07fe4a4b48e94d9389">right_to_iterator</a> (const SInt pos)</td></tr>
<tr class="separator:a2ac16155ab224c07fe4a4b48e94d9389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8119417a3be51fa56d2b261d21885b5e" id="r_a8119417a3be51fa56d2b261d21885b5e"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a8119417a3be51fa56d2b261d21885b5e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8119417a3be51fa56d2b261d21885b5e">left_to_iterator</a> (const UInt pos) const</td></tr>
<tr class="separator:a8119417a3be51fa56d2b261d21885b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5962b33d38b7d59e28af47df0c051b" id="r_afc5962b33d38b7d59e28af47df0c051b"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:afc5962b33d38b7d59e28af47df0c051b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc5962b33d38b7d59e28af47df0c051b">right_to_iterator</a> (const UInt pos) const</td></tr>
<tr class="separator:afc5962b33d38b7d59e28af47df0c051b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eec0c3d594084f2f470457c1c6b687" id="r_ab7eec0c3d594084f2f470457c1c6b687"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:ab7eec0c3d594084f2f470457c1c6b687"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7eec0c3d594084f2f470457c1c6b687">left_to_iterator</a> (const SInt pos) const</td></tr>
<tr class="separator:ab7eec0c3d594084f2f470457c1c6b687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4d958892d6617d32814cd75ee45bef" id="r_a3a4d958892d6617d32814cd75ee45bef"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:a3a4d958892d6617d32814cd75ee45bef"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a4d958892d6617d32814cd75ee45bef">right_to_iterator</a> (const SInt pos) const</td></tr>
<tr class="separator:a3a4d958892d6617d32814cd75ee45bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8795a07ddd1774d98b1f74f51963f8af" id="r_a8795a07ddd1774d98b1f74f51963f8af"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:a8795a07ddd1774d98b1f74f51963f8af"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8795a07ddd1774d98b1f74f51963f8af">left_to_const_iterator</a> (const UInt pos) const</td></tr>
<tr class="separator:a8795a07ddd1774d98b1f74f51963f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddb142915f926339b5ffc104cec219e" id="r_aeddb142915f926339b5ffc104cec219e"><td class="memTemplParams" colspan="2">template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</td></tr>
<tr class="memitem:aeddb142915f926339b5ffc104cec219e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeddb142915f926339b5ffc104cec219e">right_to_const_iterator</a> (const UInt pos) const</td></tr>
<tr class="separator:aeddb142915f926339b5ffc104cec219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998f4537bf3ffaeb5bf1c2415007dfb6" id="r_a998f4537bf3ffaeb5bf1c2415007dfb6"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:a998f4537bf3ffaeb5bf1c2415007dfb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a998f4537bf3ffaeb5bf1c2415007dfb6">left_to_const_iterator</a> (const SInt pos) const</td></tr>
<tr class="separator:a998f4537bf3ffaeb5bf1c2415007dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cde579a5a475b43ed5ee8482fbf75e" id="r_aa6cde579a5a475b43ed5ee8482fbf75e"><td class="memTemplParams" colspan="2">template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</td></tr>
<tr class="memitem:aa6cde579a5a475b43ed5ee8482fbf75e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6cde579a5a475b43ed5ee8482fbf75e">right_to_const_iterator</a> (const SInt pos) const</td></tr>
<tr class="separator:aa6cde579a5a475b43ed5ee8482fbf75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a34dda616dbb739986d1a9c3f3575" id="r_a467a34dda616dbb739986d1a9c3f3575"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467a34dda616dbb739986d1a9c3f3575">left_unconst</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos)</td></tr>
<tr class="separator:a467a34dda616dbb739986d1a9c3f3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860cb39866a1cc6629f6c622f85a337" id="r_af860cb39866a1cc6629f6c622f85a337"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af860cb39866a1cc6629f6c622f85a337">right_unconst</a> (const <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> pos)</td></tr>
<tr class="separator:af860cb39866a1cc6629f6c622f85a337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d50b9fc9beecc3b1cddc2658f23caec" id="r_a5d50b9fc9beecc3b1cddc2658f23caec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d50b9fc9beecc3b1cddc2658f23caec">left_insert</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos, const T &amp;value)</td></tr>
<tr class="separator:a5d50b9fc9beecc3b1cddc2658f23caec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46268e918b897d40cec9ae86ce7ea9" id="r_acb46268e918b897d40cec9ae86ce7ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb46268e918b897d40cec9ae86ce7ea9">right_insert</a> (const <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> pos, const T &amp;value)</td></tr>
<tr class="separator:acb46268e918b897d40cec9ae86ce7ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8eb4f3507c8672703f97cc8970038c" id="r_a6f8eb4f3507c8672703f97cc8970038c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f8eb4f3507c8672703f97cc8970038c">left_insert</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="separator:a6f8eb4f3507c8672703f97cc8970038c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0889b89ab08ea93c2564d3c1c834e75a" id="r_a0889b89ab08ea93c2564d3c1c834e75a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0889b89ab08ea93c2564d3c1c834e75a">right_insert</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos, T &amp;&amp;value)</td></tr>
<tr class="separator:a0889b89ab08ea93c2564d3c1c834e75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267ce2a70bd74014d942fe04f8251b43" id="r_a267ce2a70bd74014d942fe04f8251b43"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator Itr&gt; </td></tr>
<tr class="memitem:a267ce2a70bd74014d942fe04f8251b43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a267ce2a70bd74014d942fe04f8251b43">left_insert</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos, Itr first, Itr last)</td></tr>
<tr class="separator:a267ce2a70bd74014d942fe04f8251b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389f8bd54ea2a0f9630ff0b4f8bb07a" id="r_a0389f8bd54ea2a0f9630ff0b4f8bb07a"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator Itr&gt; </td></tr>
<tr class="memitem:a0389f8bd54ea2a0f9630ff0b4f8bb07a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0389f8bd54ea2a0f9630ff0b4f8bb07a">right_insert</a> (const <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> pos, Itr first, Itr last)</td></tr>
<tr class="separator:a0389f8bd54ea2a0f9630ff0b4f8bb07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3faa2d6bd76929e55688c5ae105616" id="r_a5a3faa2d6bd76929e55688c5ae105616"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range Range&gt; </td></tr>
<tr class="memitem:a5a3faa2d6bd76929e55688c5ae105616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a3faa2d6bd76929e55688c5ae105616">left_insert</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos, const Range &amp;range)</td></tr>
<tr class="separator:a5a3faa2d6bd76929e55688c5ae105616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab48515f501edb57365ceece6841334f" id="r_aab48515f501edb57365ceece6841334f"><td class="memTemplParams" colspan="2">template&lt;std::ranges::forward_range Range&gt; </td></tr>
<tr class="memitem:aab48515f501edb57365ceece6841334f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab48515f501edb57365ceece6841334f">right_insert</a> (const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> pos, const Range &amp;range)</td></tr>
<tr class="separator:aab48515f501edb57365ceece6841334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347e9c2309991e01a86e78767f5947e" id="r_a1347e9c2309991e01a86e78767f5947e"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a1347e9c2309991e01a86e78767f5947e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1347e9c2309991e01a86e78767f5947e">left_insert</a> (const Int pos, const T &amp;value)</td></tr>
<tr class="separator:a1347e9c2309991e01a86e78767f5947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a10a74cfba2774932f5bc5adb54eb3" id="r_a68a10a74cfba2774932f5bc5adb54eb3"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a68a10a74cfba2774932f5bc5adb54eb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68a10a74cfba2774932f5bc5adb54eb3">right_insert</a> (const Int pos, const T &amp;value)</td></tr>
<tr class="separator:a68a10a74cfba2774932f5bc5adb54eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c3e102d0e0c67b33070a5d03c1852" id="r_aa73c3e102d0e0c67b33070a5d03c1852"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:aa73c3e102d0e0c67b33070a5d03c1852"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa73c3e102d0e0c67b33070a5d03c1852">left_insert</a> (const Int pos, T &amp;&amp;value)</td></tr>
<tr class="separator:aa73c3e102d0e0c67b33070a5d03c1852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1870685aadbd5e738df5165fe9656a80" id="r_a1870685aadbd5e738df5165fe9656a80"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a1870685aadbd5e738df5165fe9656a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1870685aadbd5e738df5165fe9656a80">right_insert</a> (const Int pos, T &amp;&amp;value)</td></tr>
<tr class="separator:a1870685aadbd5e738df5165fe9656a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171a900f6cc6a7338171c9f8146e750d" id="r_a171a900f6cc6a7338171c9f8146e750d"><td class="memTemplParams" colspan="2">template&lt;class Int, std::ranges::forward_range Range&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a171a900f6cc6a7338171c9f8146e750d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a171a900f6cc6a7338171c9f8146e750d">left_insert</a> (const Int pos, const Range &amp;range)</td></tr>
<tr class="separator:a171a900f6cc6a7338171c9f8146e750d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c50af60fe7616ed5b9b5f9547891fda" id="r_a0c50af60fe7616ed5b9b5f9547891fda"><td class="memTemplParams" colspan="2">template&lt;class Int, std::ranges::forward_range Range&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a0c50af60fe7616ed5b9b5f9547891fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c50af60fe7616ed5b9b5f9547891fda">right_insert</a> (const Int pos, const Range &amp;range)</td></tr>
<tr class="separator:a0c50af60fe7616ed5b9b5f9547891fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4bc64609d2060f12be324461753b71" id="r_a1e4bc64609d2060f12be324461753b71"><td class="memTemplParams" colspan="2">template&lt;class Int, std::forward_iterator Itr&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a1e4bc64609d2060f12be324461753b71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e4bc64609d2060f12be324461753b71">left_insert</a> (const Int pos, Itr first, Itr last)</td></tr>
<tr class="separator:a1e4bc64609d2060f12be324461753b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c726b09eacdaedbc33c43cc3d28fe3" id="r_ad7c726b09eacdaedbc33c43cc3d28fe3"><td class="memTemplParams" colspan="2">template&lt;class Int, std::forward_iterator Itr&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:ad7c726b09eacdaedbc33c43cc3d28fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7c726b09eacdaedbc33c43cc3d28fe3">right_insert</a> (const Int pos, Itr first, Itr last)</td></tr>
<tr class="separator:ad7c726b09eacdaedbc33c43cc3d28fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8345392982452e0eff874db8d058cda4" id="r_a8345392982452e0eff874db8d058cda4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8345392982452e0eff874db8d058cda4">left_erase</a> (<a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> cpos)</td></tr>
<tr class="separator:a8345392982452e0eff874db8d058cda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6731610fa9ef7c41b55387966ec04e19" id="r_a6731610fa9ef7c41b55387966ec04e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6731610fa9ef7c41b55387966ec04e19">right_erase</a> (<a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> cpos)</td></tr>
<tr class="separator:a6731610fa9ef7c41b55387966ec04e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f52402dac84084e5e726f698648af5" id="r_ab0f52402dac84084e5e726f698648af5"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:ab0f52402dac84084e5e726f698648af5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0f52402dac84084e5e726f698648af5">left_erase</a> (const Int pos)</td></tr>
<tr class="separator:ab0f52402dac84084e5e726f698648af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3df4f9a02fdfc8bca54ab78ba18642" id="r_a2b3df4f9a02fdfc8bca54ab78ba18642"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a2b3df4f9a02fdfc8bca54ab78ba18642"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b3df4f9a02fdfc8bca54ab78ba18642">right_erase</a> (const Int pos)</td></tr>
<tr class="separator:a2b3df4f9a02fdfc8bca54ab78ba18642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404134af9b4af82a70c31df0faea6567" id="r_a404134af9b4af82a70c31df0faea6567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404134af9b4af82a70c31df0faea6567">left_erase</a> (<a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> first, <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> last)</td></tr>
<tr class="separator:a404134af9b4af82a70c31df0faea6567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d76357ab17981876e32c2726189a2e" id="r_a76d76357ab17981876e32c2726189a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76d76357ab17981876e32c2726189a2e">right_erase</a> (<a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> first, <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> last)</td></tr>
<tr class="separator:a76d76357ab17981876e32c2726189a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53465a411a7a338b8905ed42428a092c" id="r_a53465a411a7a338b8905ed42428a092c"><td class="memTemplParams" colspan="2">template&lt;class Callable&gt; </td></tr>
<tr class="memitem:a53465a411a7a338b8905ed42428a092c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53465a411a7a338b8905ed42428a092c">left_erase_if</a> (Callable &amp;&amp;f)</td></tr>
<tr class="separator:a53465a411a7a338b8905ed42428a092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b908a7a22fd675e24512dd69c36133" id="r_a72b908a7a22fd675e24512dd69c36133"><td class="memTemplParams" colspan="2">template&lt;class Callable&gt; </td></tr>
<tr class="memitem:a72b908a7a22fd675e24512dd69c36133"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72b908a7a22fd675e24512dd69c36133">right_erase_if</a> (Callable &amp;&amp;f)</td></tr>
<tr class="separator:a72b908a7a22fd675e24512dd69c36133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8b7cfe7d7eb9cbd48947e087400e6f" id="r_add8b7cfe7d7eb9cbd48947e087400e6f"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:add8b7cfe7d7eb9cbd48947e087400e6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add8b7cfe7d7eb9cbd48947e087400e6f">left_erase</a> (Int first, Int last)</td></tr>
<tr class="separator:add8b7cfe7d7eb9cbd48947e087400e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31760f5c328c64fe54b6ee9c9e87932b" id="r_a31760f5c328c64fe54b6ee9c9e87932b"><td class="memTemplParams" colspan="2">template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</td></tr>
<tr class="memitem:a31760f5c328c64fe54b6ee9c9e87932b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a31760f5c328c64fe54b6ee9c9e87932b">right_erase</a> (Int first, Int last)</td></tr>
<tr class="separator:a31760f5c328c64fe54b6ee9c9e87932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e6a6f5a217f87e93b954b727d810e4" id="r_ac2e6a6f5a217f87e93b954b727d810e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e6a6f5a217f87e93b954b727d810e4">left_pop_back</a> ()</td></tr>
<tr class="separator:ac2e6a6f5a217f87e93b954b727d810e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dba636704b97fb5302499049e765be0" id="r_a2dba636704b97fb5302499049e765be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dba636704b97fb5302499049e765be0">right_pop_back</a> ()</td></tr>
<tr class="separator:a2dba636704b97fb5302499049e765be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60061db57210775d01c731d69b54a313" id="r_a60061db57210775d01c731d69b54a313"><td class="memTemplParams" colspan="2">template&lt;class Function&gt; </td></tr>
<tr class="memitem:a60061db57210775d01c731d69b54a313"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60061db57210775d01c731d69b54a313">left_for_each</a> (Function &amp;&amp;function)</td></tr>
<tr class="separator:a60061db57210775d01c731d69b54a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad521c0864a620c3815e9da771e72ef83" id="r_ad521c0864a620c3815e9da771e72ef83"><td class="memTemplParams" colspan="2">template&lt;class Function&gt; </td></tr>
<tr class="memitem:ad521c0864a620c3815e9da771e72ef83"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad521c0864a620c3815e9da771e72ef83">right_for_each</a> (Function &amp;&amp;function)</td></tr>
<tr class="separator:ad521c0864a620c3815e9da771e72ef83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, std::size_t N&gt;<br />
class embed::DualArrayList&lt; T, N &gt;</div><p>Two ArrayLists that share the same memory buffer. </p>
<p>Two ArrayLists that internally grow in two different directions from opposite ends of the buffer. Internally the left array list grows to the right and the right array list grows to the back. </p><div class="fragment"><div class="line">+---------------------+---------+----------------------+</div>
<div class="line">| left array list --&gt; | <a class="code hl_function" href="#acb515edd16f1c1202d38e10c4d42e703">reserve</a> | &lt;-- right array list |</div>
<div class="line">+---------------------+---------+----------------------+</div>
<div class="ttc" id="aclassembed_1_1_dual_array_list_html_acb515edd16f1c1202d38e10c4d42e703"><div class="ttname"><a href="#acb515edd16f1c1202d38e10c4d42e703">embed::DualArrayList::reserve</a></div><div class="ttdeci">constexpr size_type reserve() const</div><div class="ttdoc">Returns the size of the reserve (aka.) number of free elements that has not been claimed by either li...</div><div class="ttdef"><b>Definition</b> DualArrayList.hpp:94</div></div>
</div><!-- fragment --><p> However, both array lists look like normal array lists. Both emplace back in the growing direction. The left has normal pointer like iterators, and the right uses internally reverse iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the value types of the container </td></tr>
    <tr><td class="paramname">N</td><td>the maximum size of the container </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a935997e01da73cafa167c9ad8f61f5d2" name="a935997e01da73cafa167c9ad8f61f5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935997e01da73cafa167c9ad8f61f5d2">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::const_pointer = const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6596356aa4feae74ca1e917e294974fd" name="a6596356aa4feae74ca1e917e294974fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6596356aa4feae74ca1e917e294974fd">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::const_reference = const T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15a067a56a615290d906bd4e69ff5f05" name="a15a067a56a615290d906bd4e69ff5f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a067a56a615290d906bd4e69ff5f05">&#9670;&#160;</a></span>left_const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_const_iterator = const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3792e2f18c3165b9c58e4dfcb906a37d" name="a3792e2f18c3165b9c58e4dfcb906a37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3792e2f18c3165b9c58e4dfcb906a37d">&#9670;&#160;</a></span>left_const_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_const_range = std::ranges::subrange&lt;<a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac89dde5db095f00a6dc761971650bc9b" name="ac89dde5db095f00a6dc761971650bc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89dde5db095f00a6dc761971650bc9b">&#9670;&#160;</a></span>left_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_iterator = T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef3178a70c9216f06dec4522c29f8ac" name="a0ef3178a70c9216f06dec4522c29f8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef3178a70c9216f06dec4522c29f8ac">&#9670;&#160;</a></span>left_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_range = std::ranges::subrange&lt;<a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9c0953f0ba924018b30d45adb3eb314" name="ae9c0953f0ba924018b30d45adb3eb314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c0953f0ba924018b30d45adb3eb314">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::pointer = T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad208c2fd2b3bb1bea13c4ace4f6b46e2" name="ad208c2fd2b3bb1bea13c4ace4f6b46e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::reference = T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a170f50229b64f2699d274c5e134a36ef" name="a170f50229b64f2699d274c5e134a36ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170f50229b64f2699d274c5e134a36ef">&#9670;&#160;</a></span>right_const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_const_iterator = std::reverse_iterator&lt;<a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7039279bf390b9c10a3a960c1f3c51ac" name="a7039279bf390b9c10a3a960c1f3c51ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7039279bf390b9c10a3a960c1f3c51ac">&#9670;&#160;</a></span>right_const_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_const_range = std::ranges::subrange&lt;<a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f1bc61a3e37397bcaf33fa9693bd634" name="a5f1bc61a3e37397bcaf33fa9693bd634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1bc61a3e37397bcaf33fa9693bd634">&#9670;&#160;</a></span>right_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_iterator = std::reverse_iterator&lt;<a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add39ffc0a861261fe003a1c993cbd700" name="add39ffc0a861261fe003a1c993cbd700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add39ffc0a861261fe003a1c993cbd700">&#9670;&#160;</a></span>right_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_range = std::ranges::subrange&lt;<a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71977d37caaecbc4e1891156aa543320" name="a71977d37caaecbc4e1891156aa543320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71977d37caaecbc4e1891156aa543320">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::size_type = std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adce44ad0a4e78db5e1f33fb50f397bd2" name="adce44ad0a4e78db5e1f33fb50f397bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce44ad0a4e78db5e1f33fb50f397bd2">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::value_type = T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae8fed78f7d3b0e439a21eb146d085846" name="ae8fed78f7d3b0e439a21eb146d085846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fed78f7d3b0e439a21eb146d085846">&#9670;&#160;</a></span>DualArrayList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::DualArrayList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructs two empty lists </p>

</div>
</div>
<a id="aa7a18fc02231154874bbe0465e0a68ca" name="aa7a18fc02231154874bbe0465e0a68ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a18fc02231154874bbe0465e0a68ca">&#9670;&#160;</a></span>DualArrayList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::DualArrayList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs both lists like from the other dual list. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60e0c44262fab5d0662840e40b97af43" name="a60e0c44262fab5d0662840e40b97af43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e0c44262fab5d0662840e40b97af43">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ad937788ca0b51a7825e19d5610fc5f" name="a8ad937788ca0b51a7825e19d5610fc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad937788ca0b51a7825e19d5610fc5f">&#9670;&#160;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a935997e01da73cafa167c9ad8f61f5d2">const_pointer</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85c4ed583a0ac535d02d249ad99c5abf" name="a85c4ed583a0ac535d02d249ad99c5abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c4ed583a0ac535d02d249ad99c5abf">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clears both lists </p>

</div>
</div>
<a id="a421f7ae6cfd90c8f9e46916e170e55c4" name="a421f7ae6cfd90c8f9e46916e170e55c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421f7ae6cfd90c8f9e46916e170e55c4">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9c0953f0ba924018b30d45adb3eb314">pointer</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3e1b2744b2edcceb423439e52aab79b" name="ae3e1b2744b2edcceb423439e52aab79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e1b2744b2edcceb423439e52aab79b">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a935997e01da73cafa167c9ad8f61f5d2">const_pointer</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1f7ca1063dad1fb64d95d24337a3134" name="ac1f7ca1063dad1fb64d95d24337a3134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f7ca1063dad1fb64d95d24337a3134">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both lists are empty </p>

</div>
</div>
<a id="af1b4aa5ae48be18369a6f6a37bd75dfb" name="af1b4aa5ae48be18369a6f6a37bd75dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b4aa5ae48be18369a6f6a37bd75dfb">&#9670;&#160;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::full </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if the lists are full, all elements have been taken by either side, no more elements can be emplaced. </p>

</div>
</div>
<a id="a4ceb56832904a96d391dbbd7c66e4d78" name="a4ceb56832904a96d391dbbd7c66e4d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceb56832904a96d391dbbd7c66e4d78">&#9670;&#160;</a></span>left_append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_append </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac062374be6a7f25cbf10ce9c9ea9879d" name="ac062374be6a7f25cbf10ce9c9ea9879d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac062374be6a7f25cbf10ce9c9ea9879d">&#9670;&#160;</a></span>left_append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>appends <code>value</code> <code>count</code> many times to the left list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>how often <code>value</code> should be <code>left_emplaced_back()</code> </td></tr>
    <tr><td class="paramname">value</td><td>the value to be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac527a8ae30380e7418b2ddb9cdb2037f" name="ac527a8ae30380e7418b2ddb9cdb2037f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac527a8ae30380e7418b2ddb9cdb2037f">&#9670;&#160;</a></span>left_append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator Itr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_append </td>
          <td>(</td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>appends a range of elements defined by foreward iterators using the closed-open principle [first, last) </p>

</div>
</div>
<a id="a49eaf71db11ae09874ddf28bbe96f65b" name="a49eaf71db11ae09874ddf28bbe96f65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49eaf71db11ae09874ddf28bbe96f65b">&#9670;&#160;</a></span>left_append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af39e3749e42474053d58ae4df8b85dd4" name="af39e3749e42474053d58ae4df8b85dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39e3749e42474053d58ae4df8b85dd4">&#9670;&#160;</a></span>left_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_assign </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0021acdeaadb111aea59d8567f6bdab" name="ac0021acdeaadb111aea59d8567f6bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0021acdeaadb111aea59d8567f6bdab">&#9670;&#160;</a></span>left_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assigns a value count many times to the left list. </p>

</div>
</div>
<a id="a5f726632fe4f4f1e35d0ac22f29c284f" name="a5f726632fe4f4f1e35d0ac22f29c284f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f726632fe4f4f1e35d0ac22f29c284f">&#9670;&#160;</a></span>left_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator Itr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_assign </td>
          <td>(</td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a8d1e1ec1b7cbe486c262f4f916119b" name="a7a8d1e1ec1b7cbe486c262f4f916119b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8d1e1ec1b7cbe486c262f4f916119b">&#9670;&#160;</a></span>left_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad55dad8520bc874b98612177038f8a03" name="ad55dad8520bc874b98612177038f8a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55dad8520bc874b98612177038f8a03">&#9670;&#160;</a></span>left_at() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt; <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; bool, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked indexing of the left list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the mask that selects which elements to get. <code>true</code> will be included, <code>false</code> excluded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d1/de2/classembed_1_1_array_list.html" title="An array of contiguous memory which is statically allocated.">ArrayList</a> that contains all values where of this where mask is <code>true</code> </dd></dl>

</div>
</div>
<a id="a05474397e7544ef5e18d31f3069a4a68" name="a05474397e7544ef5e18d31f3069a4a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05474397e7544ef5e18d31f3069a4a68">&#9670;&#160;</a></span>left_at() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt; <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; Int, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs a list of from the left list at the provided list of indices </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>a generic integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>a list of indices that should be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="../../d1/de2/classembed_1_1_array_list.html" title="An array of contiguous memory which is statically allocated.">ArrayList</a> containing all the elements from this that are contained in the <code>indices</code> </dd></dl>

</div>
</div>
<a id="ab20f94575b2009725139a655b081ce6e" name="ab20f94575b2009725139a655b081ce6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20f94575b2009725139a655b081ce6e">&#9670;&#160;</a></span>left_at() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_at </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>si</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6229164dacca6fc433edbe3c3e3cd7d8" name="a6229164dacca6fc433edbe3c3e3cd7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6229164dacca6fc433edbe3c3e3cd7d8">&#9670;&#160;</a></span>left_at() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_at </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element in the left list at the position with the given index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UInt</td><td>An unsigned integer/integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of the element to retreive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at position i </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure on out of bounds access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb8e12a7f1b412ad6673a7cca716601" name="a7fb8e12a7f1b412ad6673a7cca716601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb8e12a7f1b412ad6673a7cca716601">&#9670;&#160;</a></span>left_at() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_at </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0a92ed69ee2c73a4dd43b2545eab7bd4" name="a0a92ed69ee2c73a4dd43b2545eab7bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a92ed69ee2c73a4dd43b2545eab7bd4">&#9670;&#160;</a></span>left_at() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_at </td>
          <td>(</td>
          <td class="paramtype">SInt</td>          <td class="paramname"><span class="paramname"><em>si</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element in the left list at the wrapped position with the given index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SInt</td><td>An unsigned integer/integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">si</td><td>the index of the element to retreive, negative indices will wrap to the end of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at position <code>si</code> or <code><a class="el" href="#a9f14d57f718b42f68c52d66c380b3ed3" title="Returns the size of the left list.">left_size()</a> - si</code> depending on signdines </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure on out of bounds access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3a50ea1126c5e6106291f2dadbdbc80" name="ac3a50ea1126c5e6106291f2dadbdbc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a50ea1126c5e6106291f2dadbdbc80">&#9670;&#160;</a></span>left_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the last element in the left list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure if the list is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac57b841f5060c5d84ff32179df4c1f59" name="ac57b841f5060c5d84ff32179df4c1f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57b841f5060c5d84ff32179df4c1f59">&#9670;&#160;</a></span>left_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac43bc88a2f2b518d5d9ee8272fb71cd8" name="ac43bc88a2f2b518d5d9ee8272fb71cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43bc88a2f2b518d5d9ee8272fb71cd8">&#9670;&#160;</a></span>left_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the beginning of the left list </p>

</div>
</div>
<a id="a1a29e6bd57819aef0f0b3049cd16fefd" name="a1a29e6bd57819aef0f0b3049cd16fefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a29e6bd57819aef0f0b3049cd16fefd">&#9670;&#160;</a></span>left_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a02eb05a9d31e9bf290670dd116c22835" name="a02eb05a9d31e9bf290670dd116c22835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eb05a9d31e9bf290670dd116c22835">&#9670;&#160;</a></span>left_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the capacity of the left list. </p>

</div>
</div>
<a id="a38287399f78a40c9488cd779a81c1854" name="a38287399f78a40c9488cd779a81c1854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38287399f78a40c9488cd779a81c1854">&#9670;&#160;</a></span>left_cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2a6a576f9836ea744463c948330cfc95" name="a2a6a576f9836ea744463c948330cfc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6a576f9836ea744463c948330cfc95">&#9670;&#160;</a></span>left_cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a40a4c3484febf477560276c7ff28d168" name="a40a4c3484febf477560276c7ff28d168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a4c3484febf477560276c7ff28d168">&#9670;&#160;</a></span>left_clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clears the left list </p>
<p>destructs all members if not trivially destructible and sets the size to zero </p>

</div>
</div>
<a id="a81453a1ac2df981e962a7e5625e66716" name="a81453a1ac2df981e962a7e5625e66716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81453a1ac2df981e962a7e5625e66716">&#9670;&#160;</a></span>left_csubrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3792e2f18c3165b9c58e4dfcb906a37d">left_const_range</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_csubrange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4370e41cc235cd6a70f39ec2b884d1fd" name="a4370e41cc235cd6a70f39ec2b884d1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4370e41cc235cd6a70f39ec2b884d1fd">&#9670;&#160;</a></span>left_emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>emplaces (aka. pushes) an element to the back of the left list </p>
<p>Actually constructs an element in place </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>list of parameters that correspond to a constructor of the value type of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>list of arguments to construct a value of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the constructed list element </dd></dl>

</div>
</div>
<a id="ab0e0b2ca1fb4423aa91d59dfbf15b437" name="ab0e0b2ca1fb4423aa91d59dfbf15b437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e0b2ca1fb4423aa91d59dfbf15b437">&#9670;&#160;</a></span>left_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the left list is empty. </p>

</div>
</div>
<a id="a5de51e9472d360069c54be26b983a6ec" name="a5de51e9472d360069c54be26b983a6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de51e9472d360069c54be26b983a6ec">&#9670;&#160;</a></span>left_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator past the end of the left list </p>

</div>
</div>
<a id="a1c22b4ccebb8cc460e7c710f84e7a1fd" name="a1c22b4ccebb8cc460e7c710f84e7a1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c22b4ccebb8cc460e7c710f84e7a1fd">&#9670;&#160;</a></span>left_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab0f52402dac84084e5e726f698648af5" name="ab0f52402dac84084e5e726f698648af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f52402dac84084e5e726f698648af5">&#9670;&#160;</a></span>left_erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_erase </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add8b7cfe7d7eb9cbd48947e087400e6f" name="add8b7cfe7d7eb9cbd48947e087400e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8b7cfe7d7eb9cbd48947e087400e6f">&#9670;&#160;</a></span>left_erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_erase </td>
          <td>(</td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8345392982452e0eff874db8d058cda4" name="a8345392982452e0eff874db8d058cda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8345392982452e0eff874db8d058cda4">&#9670;&#160;</a></span>left_erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>cpos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a404134af9b4af82a70c31df0faea6567" name="a404134af9b4af82a70c31df0faea6567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404134af9b4af82a70c31df0faea6567">&#9670;&#160;</a></span>left_erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53465a411a7a338b8905ed42428a092c" name="a53465a411a7a338b8905ed42428a092c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53465a411a7a338b8905ed42428a092c">&#9670;&#160;</a></span>left_erase_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Callable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_erase_if </td>
          <td>(</td>
          <td class="paramtype">Callable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60061db57210775d01c731d69b54a313" name="a60061db57210775d01c731d69b54a313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60061db57210775d01c731d69b54a313">&#9670;&#160;</a></span>left_for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_for_each </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ac1a43931c5f4a8c59895f7cdc71063" name="a4ac1a43931c5f4a8c59895f7cdc71063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac1a43931c5f4a8c59895f7cdc71063">&#9670;&#160;</a></span>left_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the first element in the left list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure if the list is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3853c4886f59ca621c994a30eeff2640" name="a3853c4886f59ca621c994a30eeff2640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3853c4886f59ca621c994a30eeff2640">&#9670;&#160;</a></span>left_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a171a900f6cc6a7338171c9f8146e750d" name="a171a900f6cc6a7338171c9f8146e750d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171a900f6cc6a7338171c9f8146e750d">&#9670;&#160;</a></span>left_insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int, std::ranges::forward_range Range&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1347e9c2309991e01a86e78767f5947e" name="a1347e9c2309991e01a86e78767f5947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1347e9c2309991e01a86e78767f5947e">&#9670;&#160;</a></span>left_insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e4bc64609d2060f12be324461753b71" name="a1e4bc64609d2060f12be324461753b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4bc64609d2060f12be324461753b71">&#9670;&#160;</a></span>left_insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int, std::forward_iterator Itr&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa73c3e102d0e0c67b33070a5d03c1852" name="aa73c3e102d0e0c67b33070a5d03c1852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73c3e102d0e0c67b33070a5d03c1852">&#9670;&#160;</a></span>left_insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a3faa2d6bd76929e55688c5ae105616" name="a5a3faa2d6bd76929e55688c5ae105616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3faa2d6bd76929e55688c5ae105616">&#9670;&#160;</a></span>left_insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d50b9fc9beecc3b1cddc2658f23caec" name="a5d50b9fc9beecc3b1cddc2658f23caec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d50b9fc9beecc3b1cddc2658f23caec">&#9670;&#160;</a></span>left_insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a267ce2a70bd74014d942fe04f8251b43" name="a267ce2a70bd74014d942fe04f8251b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267ce2a70bd74014d942fe04f8251b43">&#9670;&#160;</a></span>left_insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator Itr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f8eb4f3507c8672703f97cc8970038c" name="a6f8eb4f3507c8672703f97cc8970038c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8eb4f3507c8672703f97cc8970038c">&#9670;&#160;</a></span>left_insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2e6a6f5a217f87e93b954b727d810e4" name="ac2e6a6f5a217f87e93b954b727d810e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e6a6f5a217f87e93b954b727d810e4">&#9670;&#160;</a></span>left_pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f14d57f718b42f68c52d66c380b3ed3" name="a9f14d57f718b42f68c52d66c380b3ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f14d57f718b42f68c52d66c380b3ed3">&#9670;&#160;</a></span>left_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the left list. </p>

</div>
</div>
<a id="a4cb231b2c614bffa79244d14935036ce" name="a4cb231b2c614bffa79244d14935036ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb231b2c614bffa79244d14935036ce">&#9670;&#160;</a></span>left_subrange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a0ef3178a70c9216f06dec4522c29f8ac">left_range</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_subrange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the left list as a subrange </p>

</div>
</div>
<a id="a2767dc5c7899e068eff50cfe8d844a12" name="a2767dc5c7899e068eff50cfe8d844a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2767dc5c7899e068eff50cfe8d844a12">&#9670;&#160;</a></span>left_subrange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3792e2f18c3165b9c58e4dfcb906a37d">left_const_range</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_subrange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a998f4537bf3ffaeb5bf1c2415007dfb6" name="a998f4537bf3ffaeb5bf1c2415007dfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998f4537bf3ffaeb5bf1c2415007dfb6">&#9670;&#160;</a></span>left_to_const_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_const_iterator </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8795a07ddd1774d98b1f74f51963f8af" name="a8795a07ddd1774d98b1f74f51963f8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8795a07ddd1774d98b1f74f51963f8af">&#9670;&#160;</a></span>left_to_const_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_const_iterator </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f10fdb21330e8459eb7d1745158b0af" name="a3f10fdb21330e8459eb7d1745158b0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f10fdb21330e8459eb7d1745158b0af">&#9670;&#160;</a></span>left_to_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8468c91808c43eb5d9ae3e7af82d1d38" name="a8468c91808c43eb5d9ae3e7af82d1d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8468c91808c43eb5d9ae3e7af82d1d38">&#9670;&#160;</a></span>left_to_iterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7eec0c3d594084f2f470457c1c6b687" name="ab7eec0c3d594084f2f470457c1c6b687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7eec0c3d594084f2f470457c1c6b687">&#9670;&#160;</a></span>left_to_iterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a880d00cd84e3ae79a8cce84d902b5adc" name="a880d00cd84e3ae79a8cce84d902b5adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880d00cd84e3ae79a8cce84d902b5adc">&#9670;&#160;</a></span>left_to_iterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8119417a3be51fa56d2b261d21885b5e" name="a8119417a3be51fa56d2b261d21885b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8119417a3be51fa56d2b261d21885b5e">&#9670;&#160;</a></span>left_to_iterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a467a34dda616dbb739986d1a9c3f3575" name="a467a34dda616dbb739986d1a9c3f3575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467a34dda616dbb739986d1a9c3f3575">&#9670;&#160;</a></span>left_unconst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::left_unconst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e2981c9e684e0d4f0d77e045d4a40be" name="a1e2981c9e684e0d4f0d77e045d4a40be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2981c9e684e0d4f0d77e045d4a40be">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximal size - is the same for left and right. </p>

</div>
</div>
<a id="ad4c47c4c81cd9f7e47fce788108aee44" name="ad4c47c4c81cd9f7e47fce788108aee44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c47c4c81cd9f7e47fce788108aee44">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a> &amp; <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigns both lists like from the other dual list. </p>

</div>
</div>
<a id="acb515edd16f1c1202d38e10c4d42e703" name="acb515edd16f1c1202d38e10c4d42e703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb515edd16f1c1202d38e10c4d42e703">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::reserve </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the reserve (aka.) number of free elements that has not been claimed by either list. </p>

</div>
</div>
<a id="a6ada1a14900858fcec62a1c8a5aeaf20" name="a6ada1a14900858fcec62a1c8a5aeaf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ada1a14900858fcec62a1c8a5aeaf20">&#9670;&#160;</a></span>right_append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_append </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74c614a96e095eca11ad6604d73d2b3c" name="a74c614a96e095eca11ad6604d73d2b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c614a96e095eca11ad6604d73d2b3c">&#9670;&#160;</a></span>right_append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>appends <code>value</code> <code>count</code> many times to the right list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>how often <code>value</code> should be <code>right_emplaced_back()</code> </td></tr>
    <tr><td class="paramname">value</td><td>the value to be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a051413018ef259965bbd4a6ef16149bc" name="a051413018ef259965bbd4a6ef16149bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051413018ef259965bbd4a6ef16149bc">&#9670;&#160;</a></span>right_append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator Itr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_append </td>
          <td>(</td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4adf2c45c9314f6ed1e09d91d9ac0a6d" name="a4adf2c45c9314f6ed1e09d91d9ac0a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adf2c45c9314f6ed1e09d91d9ac0a6d">&#9670;&#160;</a></span>right_append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_append </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1214e974a5efe764f00a5b5fe1d44a1" name="af1214e974a5efe764f00a5b5fe1d44a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1214e974a5efe764f00a5b5fe1d44a1">&#9670;&#160;</a></span>right_assign() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_assign </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adae22a16cdf93ba59c5ead82c8238ae4" name="adae22a16cdf93ba59c5ead82c8238ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae22a16cdf93ba59c5ead82c8238ae4">&#9670;&#160;</a></span>right_assign() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assigns a value count many times to the right list. </p>

</div>
</div>
<a id="a75209e37732ab85a6f0f8edd7e20c236" name="a75209e37732ab85a6f0f8edd7e20c236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75209e37732ab85a6f0f8edd7e20c236">&#9670;&#160;</a></span>right_assign() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator Itr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_assign </td>
          <td>(</td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e01e63b08a609fb6d0bcf974a636069" name="a1e01e63b08a609fb6d0bcf974a636069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e01e63b08a609fb6d0bcf974a636069">&#9670;&#160;</a></span>right_assign() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a199b1fa4905c7ef690a97dbdcd50fe" name="a6a199b1fa4905c7ef690a97dbdcd50fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a199b1fa4905c7ef690a97dbdcd50fe">&#9670;&#160;</a></span>right_at() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt; <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; bool, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Masked indexing of the right list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the mask that selects which elements to get. <code>true</code> will be included, <code>false</code> excluded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../d1/de2/classembed_1_1_array_list.html" title="An array of contiguous memory which is statically allocated.">ArrayList</a> that contains all values where of this where mask is <code>true</code> </dd></dl>

</div>
</div>
<a id="a8ac3506ba342076e5fc45a750dd45ff2" name="a8ac3506ba342076e5fc45a750dd45ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac3506ba342076e5fc45a750dd45ff2">&#9670;&#160;</a></span>right_at() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; T, N &gt; <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/de2/classembed_1_1_array_list.html">ArrayList</a>&lt; Int, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs a list of from the right list at the provided list of indices </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>a generic integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>a list of indices that should be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="../../d1/de2/classembed_1_1_array_list.html" title="An array of contiguous memory which is statically allocated.">ArrayList</a> containing all the elements from this that are contained in the <code>indices</code> </dd></dl>

</div>
</div>
<a id="ab245dbf54facb89c1f2029ea579b24dc" name="ab245dbf54facb89c1f2029ea579b24dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab245dbf54facb89c1f2029ea579b24dc">&#9670;&#160;</a></span>right_at() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_at </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>si</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8f0e454c9b51ad30be90e3f5e61ddb9f" name="a8f0e454c9b51ad30be90e3f5e61ddb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0e454c9b51ad30be90e3f5e61ddb9f">&#9670;&#160;</a></span>right_at() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_at </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element in the right list at the position with the given index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UInt</td><td>An unsigned integer/integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of the element to retreive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at position i </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure on out of bounds access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef7635148eefc0dc1130260e31f8e4ea" name="aef7635148eefc0dc1130260e31f8e4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7635148eefc0dc1130260e31f8e4ea">&#9670;&#160;</a></span>right_at() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_at </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab83542a8d008dc3f38956dc8dd92cb3e" name="ab83542a8d008dc3f38956dc8dd92cb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83542a8d008dc3f38956dc8dd92cb3e">&#9670;&#160;</a></span>right_at() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_at </td>
          <td>(</td>
          <td class="paramtype">SInt</td>          <td class="paramname"><span class="paramname"><em>si</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element in the right list at the wrapped position with the given index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SInt</td><td>An unsigned integer/integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">si</td><td>the index of the element to retreive, negative indices will wrap to the end of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the element at position <code>si</code> or <code><a class="el" href="#a99dac9de8e2b912fbc0a9663685361e7" title="Returns the size of the right list.">right_size()</a> - si</code> depending on signdines </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure on out of bounds access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a923b40ff8ffe5030c67882fea38d4692" name="a923b40ff8ffe5030c67882fea38d4692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923b40ff8ffe5030c67882fea38d4692">&#9670;&#160;</a></span>right_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the last element in the right list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure if the list is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415aadf1cbb8d93505ae81847caf84d6" name="a415aadf1cbb8d93505ae81847caf84d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415aadf1cbb8d93505ae81847caf84d6">&#9670;&#160;</a></span>right_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a87fb44b15aec97d9e542b3fada7a2d84" name="a87fb44b15aec97d9e542b3fada7a2d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fb44b15aec97d9e542b3fada7a2d84">&#9670;&#160;</a></span>right_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator ot the beginning of the right list </p>

</div>
</div>
<a id="add65c3292703f42aff3b1909a9dbae6a" name="add65c3292703f42aff3b1909a9dbae6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add65c3292703f42aff3b1909a9dbae6a">&#9670;&#160;</a></span>right_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a35d6767bc0dcf782ce8d43408ab9802d" name="a35d6767bc0dcf782ce8d43408ab9802d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d6767bc0dcf782ce8d43408ab9802d">&#9670;&#160;</a></span>right_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the capacity of the right list. </p>

</div>
</div>
<a id="afd2131ba51e6fbec775659e7dfa517a4" name="afd2131ba51e6fbec775659e7dfa517a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2131ba51e6fbec775659e7dfa517a4">&#9670;&#160;</a></span>right_cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3f098b97fbfea8431565f54cdf3144d5" name="a3f098b97fbfea8431565f54cdf3144d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f098b97fbfea8431565f54cdf3144d5">&#9670;&#160;</a></span>right_cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8e547d9a142ec41f5b094ee523262857" name="a8e547d9a142ec41f5b094ee523262857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e547d9a142ec41f5b094ee523262857">&#9670;&#160;</a></span>right_clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clears the right list </p>
<p>destructs all members if not trivially destructible and sets the size to zero </p>

</div>
</div>
<a id="add81037e7aa98d68695311fe74f61a1c" name="add81037e7aa98d68695311fe74f61a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add81037e7aa98d68695311fe74f61a1c">&#9670;&#160;</a></span>right_csubrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7039279bf390b9c10a3a960c1f3c51ac">right_const_range</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_csubrange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a812325107bdb9a4c7062b6cbd29f0ab4" name="a812325107bdb9a4c7062b6cbd29f0ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812325107bdb9a4c7062b6cbd29f0ab4">&#9670;&#160;</a></span>right_emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>emplaces (aka. pushes) an element to the back of the right list </p>
<p>Actually constructs an element in place </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>list of parameters that correspond to a constructor of the value type of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>list of arguments to construct a value of the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the constructed list element </dd></dl>

</div>
</div>
<a id="ab3fee93036f6b38d0c9abd99650fe8e6" name="ab3fee93036f6b38d0c9abd99650fe8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fee93036f6b38d0c9abd99650fe8e6">&#9670;&#160;</a></span>right_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if the right list is empty </p>

</div>
</div>
<a id="a9c5075261f249ce574783184abce8471" name="a9c5075261f249ce574783184abce8471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5075261f249ce574783184abce8471">&#9670;&#160;</a></span>right_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator past the end of the right list </p>

</div>
</div>
<a id="aae1603d1521c10c23a53ae997dd43bff" name="aae1603d1521c10c23a53ae997dd43bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1603d1521c10c23a53ae997dd43bff">&#9670;&#160;</a></span>right_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2b3df4f9a02fdfc8bca54ab78ba18642" name="a2b3df4f9a02fdfc8bca54ab78ba18642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3df4f9a02fdfc8bca54ab78ba18642">&#9670;&#160;</a></span>right_erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_erase </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31760f5c328c64fe54b6ee9c9e87932b" name="a31760f5c328c64fe54b6ee9c9e87932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31760f5c328c64fe54b6ee9c9e87932b">&#9670;&#160;</a></span>right_erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_erase </td>
          <td>(</td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6731610fa9ef7c41b55387966ec04e19" name="a6731610fa9ef7c41b55387966ec04e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6731610fa9ef7c41b55387966ec04e19">&#9670;&#160;</a></span>right_erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>cpos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76d76357ab17981876e32c2726189a2e" name="a76d76357ab17981876e32c2726189a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d76357ab17981876e32c2726189a2e">&#9670;&#160;</a></span>right_erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72b908a7a22fd675e24512dd69c36133" name="a72b908a7a22fd675e24512dd69c36133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b908a7a22fd675e24512dd69c36133">&#9670;&#160;</a></span>right_erase_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Callable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_erase_if </td>
          <td>(</td>
          <td class="paramtype">Callable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad521c0864a620c3815e9da771e72ef83" name="ad521c0864a620c3815e9da771e72ef83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad521c0864a620c3815e9da771e72ef83">&#9670;&#160;</a></span>right_for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_for_each </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f3927a687ef3a1786d8ab81a38d5043" name="a0f3927a687ef3a1786d8ab81a38d5043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3927a687ef3a1786d8ab81a38d5043">&#9670;&#160;</a></span>right_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad208c2fd2b3bb1bea13c4ace4f6b46e2">reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference of the first element in the right list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the assertion level is at least <code>O1</code> throws an assertion failure if the list is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba0fe67127c70cecd01ef07fd43b3f5c" name="aba0fe67127c70cecd01ef07fd43b3f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0fe67127c70cecd01ef07fd43b3f5c">&#9670;&#160;</a></span>right_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6596356aa4feae74ca1e917e294974fd">const_reference</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0c50af60fe7616ed5b9b5f9547891fda" name="a0c50af60fe7616ed5b9b5f9547891fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c50af60fe7616ed5b9b5f9547891fda">&#9670;&#160;</a></span>right_insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int, std::ranges::forward_range Range&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68a10a74cfba2774932f5bc5adb54eb3" name="a68a10a74cfba2774932f5bc5adb54eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a10a74cfba2774932f5bc5adb54eb3">&#9670;&#160;</a></span>right_insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7c726b09eacdaedbc33c43cc3d28fe3" name="ad7c726b09eacdaedbc33c43cc3d28fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c726b09eacdaedbc33c43cc3d28fe3">&#9670;&#160;</a></span>right_insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int, std::forward_iterator Itr&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1870685aadbd5e738df5165fe9656a80" name="a1870685aadbd5e738df5165fe9656a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1870685aadbd5e738df5165fe9656a80">&#9670;&#160;</a></span>right_insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Int&gt; <br />
requires std::is_integral_v&lt;Int&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab48515f501edb57365ceece6841334f" name="aab48515f501edb57365ceece6841334f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab48515f501edb57365ceece6841334f">&#9670;&#160;</a></span>right_insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::forward_range Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac89dde5db095f00a6dc761971650bc9b">left_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0889b89ab08ea93c2564d3c1c834e75a" name="a0889b89ab08ea93c2564d3c1c834e75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0889b89ab08ea93c2564d3c1c834e75a">&#9670;&#160;</a></span>right_insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb46268e918b897d40cec9ae86ce7ea9" name="acb46268e918b897d40cec9ae86ce7ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46268e918b897d40cec9ae86ce7ea9">&#9670;&#160;</a></span>right_insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0389f8bd54ea2a0f9630ff0b4f8bb07a" name="a0389f8bd54ea2a0f9630ff0b4f8bb07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0389f8bd54ea2a0f9630ff0b4f8bb07a">&#9670;&#160;</a></span>right_insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;std::forward_iterator Itr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Itr</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dba636704b97fb5302499049e765be0" name="a2dba636704b97fb5302499049e765be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dba636704b97fb5302499049e765be0">&#9670;&#160;</a></span>right_pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99dac9de8e2b912fbc0a9663685361e7" name="a99dac9de8e2b912fbc0a9663685361e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dac9de8e2b912fbc0a9663685361e7">&#9670;&#160;</a></span>right_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the right list. </p>

</div>
</div>
<a id="ac9415955d6deb2ecc704647a58769ff6" name="ac9415955d6deb2ecc704647a58769ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9415955d6deb2ecc704647a58769ff6">&#9670;&#160;</a></span>right_subrange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#add39ffc0a861261fe003a1c993cbd700">right_range</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_subrange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the right list as a subrange </p>

</div>
</div>
<a id="a67b95f3da04ef4f86cb61399924f2eeb" name="a67b95f3da04ef4f86cb61399924f2eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b95f3da04ef4f86cb61399924f2eeb">&#9670;&#160;</a></span>right_subrange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7039279bf390b9c10a3a960c1f3c51ac">right_const_range</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_subrange </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa6cde579a5a475b43ed5ee8482fbf75e" name="aa6cde579a5a475b43ed5ee8482fbf75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cde579a5a475b43ed5ee8482fbf75e">&#9670;&#160;</a></span>right_to_const_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_const_iterator </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeddb142915f926339b5ffc104cec219e" name="aeddb142915f926339b5ffc104cec219e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddb142915f926339b5ffc104cec219e">&#9670;&#160;</a></span>right_to_const_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_const_iterator </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a055862dbe8a9d2dd382e71fe913b33ba" name="a055862dbe8a9d2dd382e71fe913b33ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055862dbe8a9d2dd382e71fe913b33ba">&#9670;&#160;</a></span>right_to_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a15a067a56a615290d906bd4e69ff5f05">left_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ac16155ab224c07fe4a4b48e94d9389" name="a2ac16155ab224c07fe4a4b48e94d9389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac16155ab224c07fe4a4b48e94d9389">&#9670;&#160;</a></span>right_to_iterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a4d958892d6617d32814cd75ee45bef" name="a3a4d958892d6617d32814cd75ee45bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4d958892d6617d32814cd75ee45bef">&#9670;&#160;</a></span>right_to_iterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class SInt&gt; <br />
requires std::is_signed_v&lt;SInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const SInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d3b4932bcd698d1e90568ee9c2d2651" name="a4d3b4932bcd698d1e90568ee9c2d2651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3b4932bcd698d1e90568ee9c2d2651">&#9670;&#160;</a></span>right_to_iterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc5962b33d38b7d59e28af47df0c051b" name="afc5962b33d38b7d59e28af47df0c051b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5962b33d38b7d59e28af47df0c051b">&#9670;&#160;</a></span>right_to_iterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class UInt&gt; <br />
requires std::is_unsigned_v&lt;UInt&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_to_iterator </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af860cb39866a1cc6629f6c622f85a337" name="af860cb39866a1cc6629f6c622f85a337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af860cb39866a1cc6629f6c622f85a337">&#9670;&#160;</a></span>right_unconst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5f1bc61a3e37397bcaf33fa9693bd634">right_iterator</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::right_unconst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a170f50229b64f2699d274c5e134a36ef">right_const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac140b762cceebd1a30d724eca0415834" name="ac140b762cceebd1a30d724eca0415834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac140b762cceebd1a30d724eca0415834">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71977d37caaecbc4e1891156aa543320">size_type</a> <a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">embed::DualArrayList</a>&lt; T, N &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the combined size of both lists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>embed/Containers/<a class="el" href="../../dc/df2/_dual_array_list_8hpp_source.html">DualArrayList.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../da/d2e/namespaceembed.html">embed</a></li><li class="navelem"><a class="el" href="../../d2/d0d/classembed_1_1_dual_array_list.html">DualArrayList</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
