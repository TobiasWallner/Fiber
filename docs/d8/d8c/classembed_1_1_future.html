<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>embed: embed::Future&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">embed
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d8c/classembed_1_1_future.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d3/d36/classembed_1_1_future-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">embed::Future&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> and <a class="el" href="../../de/dd8/classembed_1_1_promise.html" title="Promise and Future pairs are used to synchronise values between asynchronous tasks.">Promise</a> pairs are used to synchronise values between asynchronous tasks.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/d7e/_future_8hpp_source.html">Future.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for embed::Future&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d8/d8c/classembed_1_1_future.png" usemap="#embed::Future_3C_20T_20_3E_map" alt=""/>
  <map id="embed::Future_3C_20T_20_3E_map" name="embed::Future_3C_20T_20_3E_map">
<area href="../../d9/da2/classembed_1_1_awaitable_node.html" title="Interface tobe awaited via co_await and cooperativly works together will all other embedOS async infr..." alt="embed::AwaitableNode" shape="rect" coords="0,0,140,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb5567ecd4aa18fa441fe164e43b6dcc" id="r_acb5567ecd4aa18fa441fe164e43b6dcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb5567ecd4aa18fa441fe164e43b6dcc">Future</a> ()=default</td></tr>
<tr class="separator:acb5567ecd4aa18fa441fe164e43b6dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d91f4e11841fa2bc43fdc7a1f486ea" id="r_a07d91f4e11841fa2bc43fdc7a1f486ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07d91f4e11841fa2bc43fdc7a1f486ea">Future</a> (const <a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp;)=delete</td></tr>
<tr class="separator:a07d91f4e11841fa2bc43fdc7a1f486ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7361eb0868f3881ca1f1f6666858ad30" id="r_a7361eb0868f3881ca1f1f6666858ad30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7361eb0868f3881ca1f1f6666858ad30">operator=</a> (const <a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp;)=delete</td></tr>
<tr class="separator:a7361eb0868f3881ca1f1f6666858ad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00c50676baa7e34c30b16ff4fb9b0bb" id="r_ac00c50676baa7e34c30b16ff4fb9b0bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00c50676baa7e34c30b16ff4fb9b0bb">operator=</a> (<a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp;&amp;oldFuture)</td></tr>
<tr class="separator:ac00c50676baa7e34c30b16ff4fb9b0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ee39e6eb02a413a3d787e5fc1fc186" id="r_ae1ee39e6eb02a413a3d787e5fc1fc186"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1ee39e6eb02a413a3d787e5fc1fc186">Future</a> (<a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp;&amp;oldFuture)</td></tr>
<tr class="memdesc:ae1ee39e6eb02a413a3d787e5fc1fc186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread and interrupt save move that re-registers stack pointer in between the future and the promise.  <br /></td></tr>
<tr class="separator:ae1ee39e6eb02a413a3d787e5fc1fc186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab425d7aa6558ae61afde4b4a6930fb" id="r_afab425d7aa6558ae61afde4b4a6930fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afab425d7aa6558ae61afde4b4a6930fb">~Future</a> ()</td></tr>
<tr class="separator:afab425d7aa6558ae61afde4b4a6930fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddfa5dabe06bc9bded63c37d2e7020b" id="r_a4ddfa5dabe06bc9bded63c37d2e7020b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ddfa5dabe06bc9bded63c37d2e7020b">is_connected</a> () const</td></tr>
<tr class="separator:a4ddfa5dabe06bc9bded63c37d2e7020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55103810dcdccfc208d0368d1654654a" id="r_a55103810dcdccfc208d0368d1654654a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55103810dcdccfc208d0368d1654654a">is_detatched</a> () const</td></tr>
<tr class="separator:a55103810dcdccfc208d0368d1654654a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd63d5c401e9bfa64a5e3fb0a3b17c85" id="r_abd63d5c401e9bfa64a5e3fb0a3b17c85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd63d5c401e9bfa64a5e3fb0a3b17c85">is_connected_to</a> (const <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; T &gt; &amp;promise) const</td></tr>
<tr class="memdesc:abd63d5c401e9bfa64a5e3fb0a3b17c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the promise is connected to the future.  <br /></td></tr>
<tr class="separator:abd63d5c401e9bfa64a5e3fb0a3b17c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeac1b3349e254090c92eff0de2902a" id="r_aedeac1b3349e254090c92eff0de2902a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedeac1b3349e254090c92eff0de2902a">wait</a> ()</td></tr>
<tr class="memdesc:aedeac1b3349e254090c92eff0de2902a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the value is ready or an error occured.  <br /></td></tr>
<tr class="separator:aedeac1b3349e254090c92eff0de2902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3067c4778648cb9c6c33f5bd64aa04ef" id="r_a3067c4778648cb9c6c33f5bd64aa04ef"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3067c4778648cb9c6c33f5bd64aa04ef">get</a> ()</td></tr>
<tr class="memdesc:a3067c4778648cb9c6c33f5bd64aa04ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value of the future and waits if necessary  <br /></td></tr>
<tr class="separator:a3067c4778648cb9c6c33f5bd64aa04ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf48e07eb8aec23f78b5bd814ccd98e" id="r_a6bf48e07eb8aec23f78b5bd814ccd98e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bf48e07eb8aec23f78b5bd814ccd98e">get_if</a> ()</td></tr>
<tr class="memdesc:a6bf48e07eb8aec23f78b5bd814ccd98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the value of the future and waits if necessary. If the value does not exist, a <code>nullptr</code> is being returned  <br /></td></tr>
<tr class="separator:a6bf48e07eb8aec23f78b5bd814ccd98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d8ebdc836b5130bcc91333ba7c3557" id="r_a08d8ebdc836b5130bcc91333ba7c3557"><td class="memItemLeft" align="right" valign="top">State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d8ebdc836b5130bcc91333ba7c3557">get_state</a> () const</td></tr>
<tr class="separator:a08d8ebdc836b5130bcc91333ba7c3557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdeca96063e9988a0dcf742571478a1" id="r_a4fdeca96063e9988a0dcf742571478a1"><td class="memItemLeft" align="right" valign="top">State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fdeca96063e9988a0dcf742571478a1">state</a> () const</td></tr>
<tr class="separator:a4fdeca96063e9988a0dcf742571478a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acbb4d857e847b2b45a732684ff769e" id="r_a6acbb4d857e847b2b45a732684ff769e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6acbb4d857e847b2b45a732684ff769e">is_ready</a> () const</td></tr>
<tr class="memdesc:a6acbb4d857e847b2b45a732684ff769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the value is ready to read  <br /></td></tr>
<tr class="separator:a6acbb4d857e847b2b45a732684ff769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c854e4110f0fecf1104cb900a015737" id="r_a5c854e4110f0fecf1104cb900a015737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c854e4110f0fecf1104cb900a015737">on_ready</a> (void(*callback)(const T &amp;))</td></tr>
<tr class="memdesc:a5c854e4110f0fecf1104cb900a015737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a callback that will be called if the promise is kept.  <br /></td></tr>
<tr class="separator:a5c854e4110f0fecf1104cb900a015737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84b5d1954c42047196e7b4fd92a9f81" id="r_af84b5d1954c42047196e7b4fd92a9f81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af84b5d1954c42047196e7b4fd92a9f81">operator bool</a> () const</td></tr>
<tr class="memdesc:af84b5d1954c42047196e7b4fd92a9f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts to a boolean. same as calling <code><a class="el" href="#a6acbb4d857e847b2b45a732684ff769e" title="returns true if the value is ready to read">is_ready()</a></code>.  <br /></td></tr>
<tr class="separator:af84b5d1954c42047196e7b4fd92a9f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857b72a257cc3b68c1cb8c1e8ebbd204" id="r_a857b72a257cc3b68c1cb8c1e8ebbd204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a857b72a257cc3b68c1cb8c1e8ebbd204">is_waiting</a> () const</td></tr>
<tr class="memdesc:a857b72a257cc3b68c1cb8c1e8ebbd204"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the result is not finished yet and one has to wait  <br /></td></tr>
<tr class="separator:a857b72a257cc3b68c1cb8c1e8ebbd204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ebda5442ae14671111f2fecc1bbfa2" id="r_a31ebda5442ae14671111f2fecc1bbfa2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31ebda5442ae14671111f2fecc1bbfa2">is_broken_promise</a> () const</td></tr>
<tr class="memdesc:a31ebda5442ae14671111f2fecc1bbfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the promise was not kept  <br /></td></tr>
<tr class="separator:a31ebda5442ae14671111f2fecc1bbfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc46a08c5a5e444425d94e0e6b2f8035" id="r_adc46a08c5a5e444425d94e0e6b2f8035"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc46a08c5a5e444425d94e0e6b2f8035">await_ready</a> () const noexcept override</td></tr>
<tr class="memdesc:adc46a08c5a5e444425d94e0e6b2f8035"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>co_await</code> interoperability, returns true, if the future is no longer waiting.  <br /></td></tr>
<tr class="separator:adc46a08c5a5e444425d94e0e6b2f8035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679f5cf83b34a6fbb28107f3efc620ac" id="r_a679f5cf83b34a6fbb28107f3efc620ac"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679f5cf83b34a6fbb28107f3efc620ac">await_resume</a> () noexcept</td></tr>
<tr class="memdesc:a679f5cf83b34a6fbb28107f3efc620ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>co_await</code> interoperability and optionally returns a value if one has been set.  <br /></td></tr>
<tr class="separator:a679f5cf83b34a6fbb28107f3efc620ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classembed_1_1_awaitable_node"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classembed_1_1_awaitable_node')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d9/da2/classembed_1_1_awaitable_node.html">embed::AwaitableNode</a></td></tr>
<tr class="memitem:a478a3b4833294f940a2081667250fec0 inherit pub_methods_classembed_1_1_awaitable_node" id="r_a478a3b4833294f940a2081667250fec0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/da2/classembed_1_1_awaitable_node.html#a478a3b4833294f940a2081667250fec0">~AwaitableNode</a> () noexcept=default</td></tr>
<tr class="separator:a478a3b4833294f940a2081667250fec0 inherit pub_methods_classembed_1_1_awaitable_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88fcd4e2c8849239c65a46a8ea4e2a7 inherit pub_methods_classembed_1_1_awaitable_node" id="r_ab88fcd4e2c8849239c65a46a8ea4e2a7"><td class="memTemplParams" colspan="2">template&lt;class ReturnType&gt; </td></tr>
<tr class="memitem:ab88fcd4e2c8849239c65a46a8ea4e2a7 inherit pub_methods_classembed_1_1_awaitable_node"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/da2/classembed_1_1_awaitable_node.html#ab88fcd4e2c8849239c65a46a8ea4e2a7">await_suspend</a> (std::coroutine_handle&lt; <a class="el" href="../../dd/d4c/classembed_1_1_coroutine_promise.html">embed::CoroutinePromise</a>&lt; ReturnType &gt; &gt; handle) noexcept</td></tr>
<tr class="memdesc:ab88fcd4e2c8849239c65a46a8ea4e2a7 inherit pub_methods_classembed_1_1_awaitable_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends itself to the existing linked list of coroutines and registers itself (node) as the new leaf/tail of the list by the master (container)  <br /></td></tr>
<tr class="separator:ab88fcd4e2c8849239c65a46a8ea4e2a7 inherit pub_methods_classembed_1_1_awaitable_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a697fa51a09bfecabc58fd6d07ce8f501" id="r_a697fa51a09bfecabc58fd6d07ce8f501"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a697fa51a09bfecabc58fd6d07ce8f501">Promise&lt; T &gt;</a></td></tr>
<tr class="separator:a697fa51a09bfecabc58fd6d07ce8f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0789e89aad14d96ad83c5481c7d9318" id="r_ac0789e89aad14d96ad83c5481c7d9318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0789e89aad14d96ad83c5481c7d9318">make_future_promise</a> ()</td></tr>
<tr class="memdesc:ac0789e89aad14d96ad83c5481c7d9318"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a linked future promise pair  <br /></td></tr>
<tr class="separator:ac0789e89aad14d96ad83c5481c7d9318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class embed::Future&lt; T &gt;</div><p><a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> and <a class="el" href="../../de/dd8/classembed_1_1_promise.html" title="Promise and Future pairs are used to synchronise values between asynchronous tasks.">Promise</a> pairs are used to synchronise values between asynchronous tasks. </p>
<p>If you are on a single core bare-metal embedded system (aka. all context switching is interrupt driven) you can set the <code>EMBED_SINGLE_CORE</code> definiteion flag for optimizations - smaller binary and faster execution. It will then remove all the locks and logic that is needed for multi-core thread safety.</p>
<p>Example: one wants to copy data asynchronously (for example with a DMA controller) while doing some computations in the mean time. </p><div class="fragment"><div class="line">{</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// You want to calculate for example the CRC code of some data and use a hardware module that can do that independently</span></div>
<div class="line">     <span class="comment">// The function issues a request to a hardware-unit/co-processor and returns immediately</span></div>
<div class="line">     <span class="comment">// create a future that expects a result in the future</span></div>
<div class="line">     <a class="code hl_function" href="#acb5567ecd4aa18fa441fe164e43b6dcc">Future&lt;int&gt;</a> future_crc = async_crc(data, dataLength);;</div>
<div class="line"> </div>
<div class="line">     future_crc.<a class="code hl_function" href="#a6acbb4d857e847b2b45a732684ff769e">is_ready</a>(); <span class="comment">// returns `false`</span></div>
<div class="line"> </div>
<div class="line">     <span class="comment">// In the mean time, while the CRC is being calculated, one can do some calculations</span></div>
<div class="line">     <span class="comment">// ...</span></div>
<div class="line">     <span class="comment">// ... some math ...</span></div>
<div class="line">     <span class="comment">// ...</span></div>
<div class="line">     </div>
<div class="line">     <span class="comment">// later you you want to get the value from the future - aka. the CRC calculation you call:</span></div>
<div class="line">     <span class="keywordtype">int</span> crc = future_crc.<a class="code hl_function" href="#a3067c4778648cb9c6c33f5bd64aa04ef">get</a>(); <span class="comment">// the method waits and blocks this thread until the future value is ready</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// alternatively, if you do not wait or get the value, the future and promise safely detatch in the destructor</span></div>
<div class="ttc" id="aclassembed_1_1_future_html_a3067c4778648cb9c6c33f5bd64aa04ef"><div class="ttname"><a href="#a3067c4778648cb9c6c33f5bd64aa04ef">embed::Future::get</a></div><div class="ttdeci">T &amp; get()</div><div class="ttdoc">returns the value of the future and waits if necessary</div><div class="ttdef"><b>Definition</b> Future.hpp:208</div></div>
<div class="ttc" id="aclassembed_1_1_future_html_a6acbb4d857e847b2b45a732684ff769e"><div class="ttname"><a href="#a6acbb4d857e847b2b45a732684ff769e">embed::Future::is_ready</a></div><div class="ttdeci">bool is_ready() const</div><div class="ttdoc">returns true if the value is ready to read</div><div class="ttdef"><b>Definition</b> Future.hpp:256</div></div>
<div class="ttc" id="aclassembed_1_1_future_html_acb5567ecd4aa18fa441fe164e43b6dcc"><div class="ttname"><a href="#acb5567ecd4aa18fa441fe164e43b6dcc">embed::Future::Future</a></div><div class="ttdeci">Future()=default</div></div>
</div><!-- fragment --><p>To create a future promise pair use: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> [future, promise] = <a class="code hl_function" href="../../da/d2e/namespaceembed.html#aec82ecae8adedfd3652fdad9835931c7">embed::make_future_promise&lt;int&gt;</a>();</div>
<div class="ttc" id="anamespaceembed_html_aec82ecae8adedfd3652fdad9835931c7"><div class="ttname"><a href="../../da/d2e/namespaceembed.html#aec82ecae8adedfd3652fdad9835931c7">embed::make_future_promise</a></div><div class="ttdeci">FuturePromisePair&lt; T &gt; make_future_promise()</div><div class="ttdoc">creates a linked future promise pair</div><div class="ttdef"><b>Definition</b> Future.hpp:788</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb5567ecd4aa18fa441fe164e43b6dcc" name="acb5567ecd4aa18fa441fe164e43b6dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5567ecd4aa18fa441fe164e43b6dcc">&#9670;&#160;</a></span>Future() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::Future </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07d91f4e11841fa2bc43fdc7a1f486ea" name="a07d91f4e11841fa2bc43fdc7a1f486ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d91f4e11841fa2bc43fdc7a1f486ea">&#9670;&#160;</a></span>Future() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::Future </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ee39e6eb02a413a3d787e5fc1fc186" name="ae1ee39e6eb02a413a3d787e5fc1fc186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ee39e6eb02a413a3d787e5fc1fc186">&#9670;&#160;</a></span>Future() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::Future </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>oldFuture</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread and interrupt save move that re-registers stack pointer in between the future and the promise. </p>

</div>
</div>
<a id="afab425d7aa6558ae61afde4b4a6930fb" name="afab425d7aa6558ae61afde4b4a6930fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab425d7aa6558ae61afde4b4a6930fb">&#9670;&#160;</a></span>~Future()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::~<a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adc46a08c5a5e444425d94e0e6b2f8035" name="adc46a08c5a5e444425d94e0e6b2f8035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc46a08c5a5e444425d94e0e6b2f8035">&#9670;&#160;</a></span>await_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::await_ready </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>co_await</code> interoperability, returns true, if the future is no longer waiting. </p>
<p>Returns true if the future is not waiting anymore. Note that this does not mean that it has a readable value. It could also be broken, because the promise died before it could write a value</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> is no longer waiting on the <a class="el" href="../../de/dd8/classembed_1_1_promise.html" title="Promise and Future pairs are used to synchronise values between asynchronous tasks.">Promise</a> </dd></dl>

<p>Implements <a class="el" href="../../d9/da2/classembed_1_1_awaitable_node.html#a1d579620ed892f50d21d821409ca0de6">embed::AwaitableNode</a>.</p>

</div>
</div>
<a id="a679f5cf83b34a6fbb28107f3efc620ac" name="a679f5cf83b34a6fbb28107f3efc620ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679f5cf83b34a6fbb28107f3efc620ac">&#9670;&#160;</a></span>await_resume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::await_resume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>co_await</code> interoperability and optionally returns a value if one has been set. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the value if the value has been set and <code><a class="el" href="#a6acbb4d857e847b2b45a732684ff769e" title="returns true if the value is ready to read">is_ready()</a></code> would also return <code>true</code>, returns a <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a3067c4778648cb9c6c33f5bd64aa04ef" name="a3067c4778648cb9c6c33f5bd64aa04ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3067c4778648cb9c6c33f5bd64aa04ef">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the value of the future and waits if necessary </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d5/d2f/classembed_1_1_exception.html" title="The base class for exceptions in embed">Exception</a></td><td>of type <a class="el" href="../../d5/d2f/classembed_1_1_exception.html" title="The base class for exceptions in embed">embed::Exception</a> if an error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bf48e07eb8aec23f78b5bd814ccd98e" name="a6bf48e07eb8aec23f78b5bd814ccd98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf48e07eb8aec23f78b5bd814ccd98e">&#9670;&#160;</a></span>get_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::get_if </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the value of the future and waits if necessary. If the value does not exist, a <code>nullptr</code> is being returned </p>

</div>
</div>
<a id="a08d8ebdc836b5130bcc91333ba7c3557" name="a08d8ebdc836b5130bcc91333ba7c3557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d8ebdc836b5130bcc91333ba7c3557">&#9670;&#160;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::get_state </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31ebda5442ae14671111f2fecc1bbfa2" name="a31ebda5442ae14671111f2fecc1bbfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ebda5442ae14671111f2fecc1bbfa2">&#9670;&#160;</a></span>is_broken_promise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::is_broken_promise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if the promise was not kept </p>
<p>This happens when no value was assigned to the promise before deconstruction. If this happens an <a class="el" href="../../d5/d2f/classembed_1_1_exception.html" title="The base class for exceptions in embed">Exception</a> (Derived from std::exception) will be thrown. </p>

</div>
</div>
<a id="a4ddfa5dabe06bc9bded63c37d2e7020b" name="a4ddfa5dabe06bc9bded63c37d2e7020b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddfa5dabe06bc9bded63c37d2e7020b">&#9670;&#160;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::is_connected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd63d5c401e9bfa64a5e3fb0a3b17c85" name="abd63d5c401e9bfa64a5e3fb0a3b17c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd63d5c401e9bfa64a5e3fb0a3b17c85">&#9670;&#160;</a></span>is_connected_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::is_connected_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the promise is connected to the future. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the passed promise is the one connected to this future </dd></dl>

</div>
</div>
<a id="a55103810dcdccfc208d0368d1654654a" name="a55103810dcdccfc208d0368d1654654a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55103810dcdccfc208d0368d1654654a">&#9670;&#160;</a></span>is_detatched()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::is_detatched </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6acbb4d857e847b2b45a732684ff769e" name="a6acbb4d857e847b2b45a732684ff769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acbb4d857e847b2b45a732684ff769e">&#9670;&#160;</a></span>is_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::is_ready </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the value is ready to read </p>

</div>
</div>
<a id="a857b72a257cc3b68c1cb8c1e8ebbd204" name="a857b72a257cc3b68c1cb8c1e8ebbd204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857b72a257cc3b68c1cb8c1e8ebbd204">&#9670;&#160;</a></span>is_waiting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::is_waiting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the result is not finished yet and one has to wait </p>

</div>
</div>
<a id="a5c854e4110f0fecf1104cb900a015737" name="a5c854e4110f0fecf1104cb900a015737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c854e4110f0fecf1104cb900a015737">&#9670;&#160;</a></span>on_ready()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::on_ready </td>
          <td>(</td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>callback&#160;</em></span>)(const T &amp;)</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a callback that will be called if the promise is kept. </p>
<p>Provideing a callback will redirect the promise to call the callback instead of notifieing the future. The future will be invalid and can no longer be used to receive the value. Further, only one callback can be set. Calling this function twice will throw an error. A promis must have been created before calling this function. The state of this future will turned into a 'broken promise'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a function pointer that will be called once the Promis receives a value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">a</td><td><a class="el" href="../../d5/d2f/classembed_1_1_exception.html" title="The base class for exceptions in embed">embed::Exception</a> if this function is called twice or if there is no promis attatched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af84b5d1954c42047196e7b4fd92a9f81" name="af84b5d1954c42047196e7b4fd92a9f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84b5d1954c42047196e7b4fd92a9f81">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts to a boolean. same as calling <code><a class="el" href="#a6acbb4d857e847b2b45a732684ff769e" title="returns true if the value is ready to read">is_ready()</a></code>. </p>

</div>
</div>
<a id="a7361eb0868f3881ca1f1f6666858ad30" name="a7361eb0868f3881ca1f1f6666858ad30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7361eb0868f3881ca1f1f6666858ad30">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp; <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00c50676baa7e34c30b16ff4fb9b0bb" name="ac00c50676baa7e34c30b16ff4fb9b0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00c50676baa7e34c30b16ff4fb9b0bb">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a> &amp; <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>oldFuture</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fdeca96063e9988a0dcf742571478a1" name="a4fdeca96063e9988a0dcf742571478a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdeca96063e9988a0dcf742571478a1">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::state </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedeac1b3349e254090c92eff0de2902a" name="aedeac1b3349e254090c92eff0de2902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeac1b3349e254090c92eff0de2902a">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d8c/classembed_1_1_future.html">embed::Future</a>&lt; T &gt;::wait </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the current thread until the value is ready or an error occured. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ac0789e89aad14d96ad83c5481c7d9318" name="ac0789e89aad14d96ad83c5481c7d9318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0789e89aad14d96ad83c5481c7d9318">&#9670;&#160;</a></span>make_future_promise</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a>&lt; T &gt; make_future_promise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a linked future promise pair </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> [future, promise] = <a class="code hl_friend" href="#ac0789e89aad14d96ad83c5481c7d9318">make_future_promise&lt;int&gt;</a>();</div>
<div class="ttc" id="aclassembed_1_1_future_html_ac0789e89aad14d96ad83c5481c7d9318"><div class="ttname"><a href="#ac0789e89aad14d96ad83c5481c7d9318">embed::Future::make_future_promise</a></div><div class="ttdeci">friend FuturePromisePair&lt; T &gt; make_future_promise()</div><div class="ttdoc">creates a linked future promise pair</div><div class="ttdef"><b>Definition</b> Future.hpp:788</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type that is being promised by the promise and awaited by the future </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linked <code><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a></code> <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> promise pair </dd></dl>

</div>
</div>
<a id="a697fa51a09bfecabc58fd6d07ce8f501" name="a697fa51a09bfecabc58fd6d07ce8f501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697fa51a09bfecabc58fd6d07ce8f501">&#9670;&#160;</a></span>Promise&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>embed/OS/<a class="el" href="../../d5/d7e/_future_8hpp_source.html">Future.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../da/d2e/namespaceembed.html">embed</a></li><li class="navelem"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
