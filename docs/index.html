<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>embed: EmbedOS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">embed
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">EmbedOS </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a></p>
<p>Version: early alpha</p>
<p><a href="https://tobiaswallner.github.io/embedOS/">Documentation</a></p>
<p>Copyright ¬© Tobias Wallner</p>
<h1><a class="anchor" id="autotoc_md0"></a>
‚ö° Motivation</h1>
<p>Modern embedded systems demand more than just correctness‚Äîthey demand <b>performance</b>, <b>dependability</b>, <b>Real-Time</b> and <b>predictability</b>.</p>
<p>Traditional RTOSes rely on <b>context switching</b>, are <b>stack-heavy</b> and use <b>interrupt driven preemption</b>, which introduce runtime overhead and memory waste.</p>
<blockquote class="doxtable">
<p><b>What if task switching is just a state machine?</b> </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md1"></a>
üåÄ Coroutine-powered, zero-waste tasking</h2>
<p>By using <b>C++20 coroutines</b>, tasks in <code>embedOS</code> are structured as lightweight state machines with no context-switching and interrupt overhead. The syntax is modern, expressive, and reads like a simple switch, no unreadable branching necessary:</p>
<div class="fragment"><div class="line">Coroutine&lt;Exit&gt; coroutine(){</div>
<div class="line">  send_data(tx_data);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Task suspends ‚Äî another task runs</span></div>
<div class="line">  <span class="keyword">auto</span> rx_data = <span class="keyword">co_await</span> receive_data();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Start async HW operation</span></div>
<div class="line">  Future&lt;uint32_t&gt; future_crc = hardware_crc(rx_data); </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use CPU in the meantime</span></div>
<div class="line">  value = calculate(rx_data);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Yield until HW finishes</span></div>
<div class="line">  uint32_t crc <span class="keyword">co_await</span> future_crc;</div>
<div class="line">  <span class="keyword">co_return</span> Exit::Success;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Each task suspends explicitly at <code>co_await</code> points, allowing others to run. No busy-waiting, no polling, no thread stacks. Just pure, cooperative, non-blocking execution.</p>
<p>The OS is just the scheduler of your choice, add some tasks and let it spin. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  CoTask task(coroutine(), <span class="stringliteral">&quot;task&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  embed::StaticLinearScheduler scheduler;</div>
<div class="line">  scheduler.addTask(task);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>){</div>
<div class="line">    scheduler.spin();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Want multithreading? Just create a scheduler for each core.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
‚è± Real-Time scheduling</h2>
<p>With embedOS, you can declare tasks with explicit timing guarantees: </p><div class="fragment"><div class="line">PeriodicTask task(<span class="comment">/* period */</span> 1ms, <span class="comment">/* deadline */</span> 100us);</div>
</div><!-- fragment --><p>The scheduler enforces <b>deadlines</b> with priority queues and can track deadline misses precisely and handles timer/clock overflows. Your tasks run when they must‚Äîand only when they should.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
üí° Stackless, deterministic memory usage</h2>
<p>One of the biggest hidden costs in traditional RTOSes is <b>stack sizing</b>. You guess how big each task‚Äôs stack should be.</p><ul>
<li>Too small and you get stack overflows and corrupted memory.</li>
<li>Too large and you waste precious RAM.</li>
</ul>
<h3><a class="anchor" id="autotoc_md4"></a>
üéØ In embedOS, there's no guessing.</h3>
<p>Each coroutine task <b>allocates exactly</b> as much memory as needed, in the <b>initialisation</b>, to store its state at suspension points. The system never stores full stacks‚Äîonly the <b>delta state</b>, reducing memory usage by 5x to 10x compared to traditional context switching.</p>
<p>No stack overflow. No corrupted memory. No waste. Just predictable, dependable engineering.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
üîê Dependability by Design</h2>
<p><code>embedOS</code> is built with dependability as a first-class concern, not a reactive patch.</p>
<p>Unlike traditional RTOSes that rely on threads, shared stacks, and weak exception handling, <code>embedOS</code> uses structured coroutines, deterministic control flow, and explicit task ownership to provide built-in fault isolation and graceful failure handling.</p>
<p>Each task is fully isolated: an exception only affects that task. The rest of the system runs uninterrupted.</p>
<p>What This Means for You:</p><ul>
<li>A single task crashing won‚Äôt bring down your system</li>
<li>You don‚Äôt need hardware MMU or MPU protection to isolate behavior</li>
<li>You get the freedom of concurrency with the safety of separation</li>
<li>You can log, recover, or restart failed tasks at runtime</li>
<li>embedOS brings fail-operational behavior to bare-metal systems</li>
<li>without threads, without stacks, without interrupts</li>
<li>on a single core/or multi if you feel fancy.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
üîç Who is embedOS for?</h1>
<p>If you‚Äôre unsure whether embedOS is right for your project, this section will help you decide‚Äîand if it‚Äôs not, we‚Äôll gladly point you toward alternatives that might serve you better. We‚Äôre not here to compete with every RTOS‚Äîwe're here to <b>fill a niche</b>. We believe in putting the power back in the engineer‚Äôs hands with a minimal and deterministic scheduling model that gets out of your way.</p>
<p>Here‚Äôs how embedOS compares to other common choices:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadNone"><b>Zephyr</b>   </th><th class="markdownTableHeadNone"><b>FreeRTOS</b>   </th><th class="markdownTableHeadNone"><b>embedOS</b> (this project)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Philosophy</b>   </td><td class="markdownTableBodyNone">Full-featured ecosystem   </td><td class="markdownTableBodyNone">Lightweight priority based task management   </td><td class="markdownTableBodyNone"><b>real Real-Time</b> deadline based task management with high CPU efficiency    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Use Case</b>   </td><td class="markdownTableBodyNone">IoT, industrial, networking   </td><td class="markdownTableBodyNone">General embedded apps   </td><td class="markdownTableBodyNone"><b>"real" Real-time control</b>, <b>constrained systems</b>, <b>highly-dependable/predictable systems</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Scheduling</b>   </td><td class="markdownTableBodyNone">complex priority-based, preemptive   </td><td class="markdownTableBodyNone">priority-based, preemptive, time slicing   </td><td class="markdownTableBodyNone"><b>deadline-based</b>, cooperative    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Threading Model</b>   </td><td class="markdownTableBodyNone">Full threads, context switching, per-thread stacks   </td><td class="markdownTableBodyNone">Tasks with independent stacks and context switching   </td><td class="markdownTableBodyNone"><b>Coroutines</b> coroutine frame buffers instead of stacks, no context switching, state machine task management    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Memory Usage per Task</b>   </td><td class="markdownTableBodyNone">High (&gt;1kB), full-stack, depends on configuration and features   </td><td class="markdownTableBodyNone">Moderate (&gt;1kB), requires full-stack per task   </td><td class="markdownTableBodyNone"><b>Extremely low</b> (~128B), no stacks, small coroutine frames    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Binary Footprint</b>   </td><td class="markdownTableBodyNone">High, 300kB‚Äì500kB+ depending on config   </td><td class="markdownTableBodyNone">Low, ~10kB‚Äì100kB   </td><td class="markdownTableBodyNone">**&lt;10kB for Scheduler**, 30‚Äì100kB including extras    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Peripheral Handling</b>   </td><td class="markdownTableBodyNone">Device tree, HAL, built-in driver APIs   </td><td class="markdownTableBodyNone">User-defined, often with vendor HAL   </td><td class="markdownTableBodyNone">**No interference**‚Äîyou write your own, OS doesn't touch your peripherals    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Context Switch Overhead</b>   </td><td class="markdownTableBodyNone">~200‚Äì1500 cycles, sometimes more   </td><td class="markdownTableBodyNone">100‚Äì600 cycles (stack switch + cpu register save/load)   </td><td class="markdownTableBodyNone">30‚Äì100 CPU cycles (function call + frame jump)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Platform Support</b>   </td><td class="markdownTableBodyNone">Pre-built boards + some MCUs and SoCs   </td><td class="markdownTableBodyNone">Wide MCU support, especially with vendor integrations   </td><td class="markdownTableBodyNone">**Widest support**‚Äîdesigned to run anywhere that compiles C++. Not tied to any platform or architecture    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Build System</b>   </td><td class="markdownTableBodyNone">CMake + Kconfig (Linux-style)   </td><td class="markdownTableBodyNone">PlatformIO/Make/CMake   </td><td class="markdownTableBodyNone">CMake/Your own build system. embedOS is just a simple library. Package manager support: <code>CPM.cmake</code>   </td></tr>
</table>
<p>If you still don‚Äôt know which one to pick, reach out‚Äîwe‚Äôll help you find the right one, even if it‚Äôs not us.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
‚ú® Features</h1>
<ul>
<li>‚öôÔ∏è <b>Cooperative Real-Time Scheduling (<code>embedOS</code>)</b><ul>
<li>The heart of embed: a <b>cooperative, coroutine-based, real-time scheduler</b></li>
<li>Uses <code>co_await</code>-based tasks with structured parent-child relationships</li>
<li>Deadline-driven scheduling with optional yielding, delaying, awaiting</li>
<li>No threads, no stacks‚Äîjust pure control flow</li>
<li>Supports task failure propagation, exception handling, and kill-safe teardown</li>
</ul>
</li>
<li>üßÆ <b>Fixed-Size, Stack-Friendly Containers</b><ul>
<li><code>StaticArrayList</code>, <code>StaticPriorityQueue</code>, <code>StaticLinearAllocator</code> and more</li>
<li>Designed for bounded memory environments (MCUs, no heap)</li>
<li>Fast, safe, and easy to reason about</li>
</ul>
</li>
<li>üîß <b>Custom Allocator Support</b><ul>
<li>Easily override coroutine frame allocation, exception memory, dynamic data</li>
<li>Control exactly how and where memory is used‚Äîno malloc required</li>
</ul>
</li>
<li>üñ®Ô∏è <b>Powerful Output Streaming</b><ul>
<li>Fully featured <code>OStream</code> with <code>operator&lt;&lt;</code> formatting</li>
<li>Supports strings, booleans, integers, floats (scientific/engineering) (small footprint)</li>
<li>Width, alignment, padding, decimal/thousand separators</li>
<li>Optional ANSI color formatting for terminal output</li>
</ul>
</li>
<li>ü™ì <b>System Stub Overrides (Binary Size Killers)</b><ul>
<li>Replaces exit-to-main code, because embedded never exits</li>
<li>Removes unused libc glue code</li>
<li>Up to <b>90% binary size reduction</b> when enabling exceptions on Cortex-M</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
üß† Design Philosophy</h1>
<ul>
<li><b>No Context Switches</b>: Tasks are C++20 coroutines that the compiler will turn into switch statements.</li>
<li><b>Cooperative</b>: Users must explicitly <code>co_await</code> or <code>co_return</code>. No task is ever preempted.</li>
<li><b>Explicit deadlines</b>: Finally a real-RTOS. You control timing windows explicitly. Start time and deadline are part of every task.</li>
<li><b>Safe Exceptions</b>: Uses exceptions safely, with zero heap allocations or overhead. It just jumps from the <code>throw</code> directly to your <code>catch</code>. No need to pass error values around. Exceptions might even reduce your binary size.</li>
<li><b>Minimal</b>: Small binary. No interrupts, no stacks, no ISRs. Minimal Flash footprint.</li>
<li><b>Portable</b>: Just provide a <code>time()</code> function and run <code>.spin()</code> in your main loop. Fully platform-agnostic, does not depend on any MCU architectures.</li>
<li><b>Customizeable</b>: Allows you to overwrite/redirect critical functions like <code><a class="el" href="da/d2e/namespaceembed.html#afca9b6603fe5654bfda9f78552324031" title="Function that the embed:: library uses to copy memory.">embed::memcpy()</a></code> or default output character streams <code><a class="el" href="da/d2e/namespaceembed.html#a09b081abf25eac7c5df285045f3baa3a">embed::cout()</a></code>. So you can hook in your own functions that use your on chips DMA controler or USART peripherals.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
üß© Integration</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
(Preferred) <a href="https://cmake.org/">CMake</a> and <a href="https://github.com/cpm-cmake/CPM.cmake">CPM.cmake</a></h2>
<ul>
<li><a href="https://cmake.org/">CMake</a> is a build tool generator in witch you can specify how C++ project files should be compiled.</li>
<li><a href="https://github.com/cpm-cmake/CPM.cmake">CPM.cmake</a> is a package manager - just a CMake script that you download and include - that will download, integrate, build and cache source libraries for you. I also allows to build everything always from source with the same compile options/flags, which makes this perfect for embedded.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
<a href="https://cmake.org/">CMake</a> with its command <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html"><code>FetchContent</code></a></h2>
<h2><a class="anchor" id="autotoc_md12"></a>
<a href="https://cmake.org/">CMake</a> with its command <a href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html"><code>add_subdirectory</code></a></h2>
<h2><a class="anchor" id="autotoc_md13"></a>
üõ† Don't Want to Use CMake?</h2>
<p>No worries. If you're using STM32CubeIDE, Atmel Studio, or Keil:</p>
<ul>
<li>Add all .cpp files from <code>embed/*</code> to your project.</li>
<li>Include <code>/embed/</code> to your include path.</li>
<li>Start using #include &lt;embed/xxx.hpp&gt; and you're good to go.</li>
</ul>
<p>‚ùó But seriously, you should try <a href="https://cmake.org/">CMake</a>. It's awesome.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
üìú Licensing</h1>
<p>embed is dual-licensed under a Qt-style model:</p>
<p>See <a href="./LICENSE"><code>LICENSE</code></a></p>
<h2><a class="anchor" id="autotoc_md15"></a>
‚úÖ Open Source License (MIT)</h2>
<p>You may use embed freely in open source projects under the following conditions:</p>
<ul>
<li>Your project must also be open source (any OSI-approved license).</li>
<li>Any modifications to embed must be shared publicly under the same license.</li>
<li>You must retain attribution to the original author.</li>
</ul>
<p>See <a href="./LICENSE_OPEN_SOURCE"><code>LICENSE_OPEN_SOURCE</code></a></p>
<h2><a class="anchor" id="autotoc_md16"></a>
üíº Commercial License (for Closed/Proprietary Projects)</h2>
<p>If you're using embed in a commercial product or closed-source firmware, you must purchase a commercial license.</p>
<p>With a commercial license, you gain:</p>
<ul>
<li>Direct developer support (tiered options)</li>
<li>License-backed usage rights</li>
<li>Priority handling for bug reports and feature requests</li>
</ul>
<p>See <code>LICENSE_COMMERCIAL</code></p>
<p>üëâ Contact: <a href="#" onclick="location.href='mai'+'lto:'+'tob'+'ia'+'s.w'+'al'+'lne'+'r1'+'@gm'+'x.'+'com'; return false;">tobia<span class="obfuscator">.nosp@m.</span>s.wa<span class="obfuscator">.nosp@m.</span>llner<span class="obfuscator">.nosp@m.</span>1@gm<span class="obfuscator">.nosp@m.</span>x.com</a> for license quotes and support plans. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
