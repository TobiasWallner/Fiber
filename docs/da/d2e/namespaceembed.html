<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>embed: embed Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">embed
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/d2e/namespaceembed.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">embed Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d58/namespaceembed_1_1ansi.html">ansi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d43/classembed_1_1_allocation_failure.html">AllocationFailure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc3/classembed_1_1_assertion_failure.html">AssertionFailure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfa/classembed_1_1_assertion_failure_critical.html">AssertionFailureCritical</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classembed_1_1_assertion_failure_full.html">AssertionFailureFull</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfd/classembed_1_1_assertion_failure_o1.html">AssertionFailureO1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/da2/classembed_1_1_awaitable_node.html">AwaitableNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface tobe awaited via <code>co_await</code> and cooperativly works together will all other <code>embedOS</code> async infrastructure.  <a href="../../d9/da2/classembed_1_1_awaitable_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for an overflow aware clock type for the use with <code><a class="el" href="#af176ead949b706e7d5afcb8ddb67b543" title="Overflow aware time point.">TimePoint</a></code>  <a href="../../da/d86/structembed_1_1_clock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d21/classembed_1_1_clock_tick.html">ClockTick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overflow aware tick class template to simulate the behaviour of hardware timers in microcontrollers for use in <a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f" title="Overflow aware time duration type.">Duration</a> and <a class="el" href="#af176ead949b706e7d5afcb8ddb67b543" title="Overflow aware time point.">TimePoint</a> types.  <a href="../../d3/d21/classembed_1_1_clock_tick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d0f/classembed_1_1_coroutine.html">Coroutine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd8/classembed_1_1_coroutine_node.html">CoroutineNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4c/classembed_1_1_coroutine_promise.html">CoroutinePromise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d04/structembed_1_1_coroutine_promise_size.html">CoroutinePromiseSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d46/classembed_1_1_co_task.html">CoTask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2f/classembed_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for exceptions in <code>embed</code>  <a href="../../d5/d2f/classembed_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/structembed_1_1_format_bool.html">FormatBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">formats a bool for use with <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html" title="Abstract class for an output character stream that offers string and number formating.">OStream</a>  <a href="../../d8/d02/structembed_1_1_format_bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d01/structembed_1_1_format_bool_param.html">FormatBoolParam</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d05/structembed_1_1_format_float.html">FormatFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an floating point for further printing use.  <a href="../../d8/d05/structembed_1_1_format_float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dff/structembed_1_1_format_float_params.html">FormatFloatParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d27/structembed_1_1_format_hex.html">FormatHex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dbb/structembed_1_1_format_hex_params.html">FormatHexParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d25/structembed_1_1_format_int.html">FormatInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats an unsigned integer (of any size) for use with <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html" title="Abstract class for an output character stream that offers string and number formating.">OStream</a>.  <a href="../../d7/d25/structembed_1_1_format_int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc7/structembed_1_1_format_int_params.html">FormatIntParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d23/structembed_1_1_format_str.html">FormatStr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats a string and allows to pass an additional size parameter.  <a href="../../dc/d23/structembed_1_1_format_str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dcb/structembed_1_1_format_str_params.html">FormatStrParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8c/classembed_1_1_future.html">Future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> and <a class="el" href="../../de/dd8/classembed_1_1_promise.html" title="Promise and Future pairs are used to synchronise values between asynchronous tasks.">Promise</a> pairs are used to synchronise values between asynchronous tasks.  <a href="../../d8/d8c/classembed_1_1_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d19/classembed_1_1_interrupt_guard.html">InterruptGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure that equaly many interrupt disable and enable calls are beingmade.  <a href="../../d9/d19/classembed_1_1_interrupt_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2d/structembed_1_1is__std__ratio.html">is_std_ratio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9b/structembed_1_1is__std__ratio_3_01std_1_1ratio_3_01_num_00_01_den_01_4_01_4.html">is_std_ratio&lt; std::ratio&lt; Num, Den &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d78/classembed_1_1_i_scheduler.html">IScheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for an output character stream that offers string and number formating.  <a href="../../da/d0a/classembed_1_1_o_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd8/classembed_1_1_promise.html" title="Promise and Future pairs are used to synchronise values between asynchronous tasks.">Promise</a> and <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> pairs are used to synchronise values between asynchronous tasks.  <a href="../../de/dd8/classembed_1_1_promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of contiguous memory which is statically allocated.  <a href="../../d5/def/classembed_1_1_static_array_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df6/structembed_1_1_static_linear_allocator.html">StaticLinearAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear allocator that uses stack memory and follows <code>std::pmr::memory_resource</code>  <a href="../../d6/df6/structembed_1_1_static_linear_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dab/classembed_1_1_static_linear_allocator_debug.html">StaticLinearAllocatorDebug</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d60/classembed_1_1_static_priority_queue.html">StaticPriorityQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d99/structembed_1_1str__add__float__params.html">str_add_float_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dba/structembed_1_1str__add__uint__params.html">str_add_uint_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/ddb/conceptembed_1_1_c_string_view.html">CStringView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df5/conceptembed_1_1_c_std_ratio.html">CStdRatio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d21/conceptembed_1_1is__power__of__two.html">is_power_of_two</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da3/conceptembed_1_1_c_clock.html">CClock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a clock with overflow awareness. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0223e2bd607a0788b0c7955a65dfe73f" id="r_a0223e2bd607a0788b0c7955a65dfe73f"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral UInt, CStdRatio Period = std::ratio&lt;1&gt;, UInt MaxTick = std::numeric_limits&lt;UInt&gt;::max()&gt; </td></tr>
<tr class="memitem:a0223e2bd607a0788b0c7955a65dfe73f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f">Duration</a> = std::chrono::duration&lt;<a class="el" href="../../d3/d21/classembed_1_1_clock_tick.html">ClockTick</a>&lt;UInt, MaxTick&gt;, Period&gt;</td></tr>
<tr class="memdesc:a0223e2bd607a0788b0c7955a65dfe73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overflow aware time duration type.  <br /></td></tr>
<tr class="separator:a0223e2bd607a0788b0c7955a65dfe73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af176ead949b706e7d5afcb8ddb67b543" id="r_af176ead949b706e7d5afcb8ddb67b543"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, std::unsigned_integral UInt = Clock::value_type, CStdRatio Period = Clock::period, UInt MaxTick = Clock::max_tick&gt; </td></tr>
<tr class="memitem:af176ead949b706e7d5afcb8ddb67b543"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af176ead949b706e7d5afcb8ddb67b543">TimePoint</a> = std::chrono::time_point&lt;<a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, <a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f">Duration</a>&lt;UInt, Period, MaxTick&gt;&gt;</td></tr>
<tr class="memdesc:af176ead949b706e7d5afcb8ddb67b543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overflow aware time point.  <br /></td></tr>
<tr class="separator:af176ead949b706e7d5afcb8ddb67b543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae2cdc9f9929967b62dfcec7be0e6c2f1" id="r_ae2cdc9f9929967b62dfcec7be0e6c2f1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2cdc9f9929967b62dfcec7be0e6c2f1">Exit</a> { <a class="el" href="#ae2cdc9f9929967b62dfcec7be0e6c2f1a505a83f220c02df2f85c3810cd9ceb38">Success</a>
, <a class="el" href="#ae2cdc9f9929967b62dfcec7be0e6c2f1ae139a585510a502bbf1841cf589f5086">Failure</a>
 }</td></tr>
<tr class="separator:ae2cdc9f9929967b62dfcec7be0e6c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caae6bd6b5d592b288dfcf439e8b326" id="r_a8caae6bd6b5d592b288dfcf439e8b326"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8caae6bd6b5d592b288dfcf439e8b326">AlignmentLRC</a> { <a class="el" href="#a8caae6bd6b5d592b288dfcf439e8b326a945d5e233cf7d6240f6b783b36a374ff">Left</a>
, <a class="el" href="#a8caae6bd6b5d592b288dfcf439e8b326a92b09c7c48c520c3c55e497875da437c">Right</a>
, <a class="el" href="#a8caae6bd6b5d592b288dfcf439e8b326a4f1f6016fc9f3f2353c0cc7c67b292bd">Center</a>
 }</td></tr>
<tr class="separator:a8caae6bd6b5d592b288dfcf439e8b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ce549beb48db3ec13fd89ecd7c333d" id="r_a22ce549beb48db3ec13fd89ecd7c333d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ce549beb48db3ec13fd89ecd7c333d">FloatRepresentation</a> { <a class="el" href="#a22ce549beb48db3ec13fd89ecd7c333da21234a0e100d74037a4da2e53f3200d7">Scientific</a>
, <a class="el" href="#a22ce549beb48db3ec13fd89ecd7c333daab0268fb8036a892dc341945cb7ae3be">Engineering</a>
, <a class="el" href="#a22ce549beb48db3ec13fd89ecd7c333dabbd47109890259c0127154db1af26c75">Full</a>
 }</td></tr>
<tr class="memdesc:a22ce549beb48db3ec13fd89ecd7c333d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify the formating of floating point numbers.  <a href="#a22ce549beb48db3ec13fd89ecd7c333d">More...</a><br /></td></tr>
<tr class="separator:a22ce549beb48db3ec13fd89ecd7c333d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:accfd2376bed93325057bafd88789b98f" id="r_accfd2376bed93325057bafd88789b98f"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N, class Function&gt; </td></tr>
<tr class="memitem:accfd2376bed93325057bafd88789b98f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accfd2376bed93325057bafd88789b98f">for_each</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N &gt; &amp;list, Function &amp;&amp;function)</td></tr>
<tr class="separator:accfd2376bed93325057bafd88789b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1fd5b05253b9d2742f1ae2dc74a36" id="r_abbf1fd5b05253b9d2742f1ae2dc74a36"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N&gt; </td></tr>
<tr class="memitem:abbf1fd5b05253b9d2742f1ae2dc74a36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbf1fd5b05253b9d2742f1ae2dc74a36">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N &gt; &amp;array)</td></tr>
<tr class="memdesc:abbf1fd5b05253b9d2742f1ae2dc74a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the array list to the output stream  <br /></td></tr>
<tr class="separator:abbf1fd5b05253b9d2742f1ae2dc74a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda99a6f8c3a15238a76cf7426646b4" id="r_a6dda99a6f8c3a15238a76cf7426646b4"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a6dda99a6f8c3a15238a76cf7426646b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6dda99a6f8c3a15238a76cf7426646b4">skalar_equal</a> (const T1 &amp;l, const T2 &amp;r)</td></tr>
<tr class="separator:a6dda99a6f8c3a15238a76cf7426646b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8908ffebee1acb8f00dce51af1244f0" id="r_af8908ffebee1acb8f00dce51af1244f0"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:af8908ffebee1acb8f00dce51af1244f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8908ffebee1acb8f00dce51af1244f0">skalar_not_equal</a> (const T1 &amp;l, const T2 &amp;r)</td></tr>
<tr class="separator:af8908ffebee1acb8f00dce51af1244f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a97347ee56fb5b9f79bb0148a6af579" id="r_a0a97347ee56fb5b9f79bb0148a6af579"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a0a97347ee56fb5b9f79bb0148a6af579"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a97347ee56fb5b9f79bb0148a6af579">skalar_less</a> (const T1 &amp;l, const T2 &amp;r)</td></tr>
<tr class="separator:a0a97347ee56fb5b9f79bb0148a6af579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f3965ef5e0ce426ebd7f87edf9306" id="r_a6a6f3965ef5e0ce426ebd7f87edf9306"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a6a6f3965ef5e0ce426ebd7f87edf9306"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a6f3965ef5e0ce426ebd7f87edf9306">skalar_greater</a> (const T1 &amp;l, const T2 &amp;r)</td></tr>
<tr class="separator:a6a6f3965ef5e0ce426ebd7f87edf9306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b88a131e36c38fbce4439ea392ca566" id="r_a4b88a131e36c38fbce4439ea392ca566"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a4b88a131e36c38fbce4439ea392ca566"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b88a131e36c38fbce4439ea392ca566">skalar_less_equal</a> (const T1 &amp;l, const T2 &amp;r)</td></tr>
<tr class="separator:a4b88a131e36c38fbce4439ea392ca566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b24f542093876435e03886bd95d505c" id="r_a8b24f542093876435e03886bd95d505c"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a8b24f542093876435e03886bd95d505c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b24f542093876435e03886bd95d505c">skalar_greater_equal</a> (const T1 &amp;l, const T2 &amp;r)</td></tr>
<tr class="separator:a8b24f542093876435e03886bd95d505c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbecfc83a78e298a7740b8c6c87cdd25" id="r_acbecfc83a78e298a7740b8c6c87cdd25"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:acbecfc83a78e298a7740b8c6c87cdd25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acbecfc83a78e298a7740b8c6c87cdd25">compare</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast, std::function&lt; bool(const T1 &amp;l, const T2 &amp;r)&gt; compare, bool Default=false)</td></tr>
<tr class="memdesc:acbecfc83a78e298a7740b8c6c87cdd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares the ranges given by closed-open iterators  <br /></td></tr>
<tr class="separator:acbecfc83a78e298a7740b8c6c87cdd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d24cf724b88db46b5d08e62c61535c2" id="r_a8d24cf724b88db46b5d08e62c61535c2"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a8d24cf724b88db46b5d08e62c61535c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d24cf724b88db46b5d08e62c61535c2">equal</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast)</td></tr>
<tr class="memdesc:a8d24cf724b88db46b5d08e62c61535c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if both ranges are equal in value and count  <br /></td></tr>
<tr class="separator:a8d24cf724b88db46b5d08e62c61535c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224c65075595660c444f070fd93c0f9" id="r_ac224c65075595660c444f070fd93c0f9"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:ac224c65075595660c444f070fd93c0f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac224c65075595660c444f070fd93c0f9">not_equal</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast)</td></tr>
<tr class="memdesc:ac224c65075595660c444f070fd93c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the ranges are not equal in value nor count  <br /></td></tr>
<tr class="separator:ac224c65075595660c444f070fd93c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b39257b05de550d42394d01053915d3" id="r_a0b39257b05de550d42394d01053915d3"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a0b39257b05de550d42394d01053915d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b39257b05de550d42394d01053915d3">less</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast)</td></tr>
<tr class="memdesc:a0b39257b05de550d42394d01053915d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the ranges are equal in count and the left ranges value are all smaller than the right ones  <br /></td></tr>
<tr class="separator:a0b39257b05de550d42394d01053915d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef275b91927e0abdc24e71807be5a539" id="r_aef275b91927e0abdc24e71807be5a539"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:aef275b91927e0abdc24e71807be5a539"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef275b91927e0abdc24e71807be5a539">greater</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast)</td></tr>
<tr class="memdesc:aef275b91927e0abdc24e71807be5a539"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the ranges are equal in count and the left ranges value are all greater than the right ones  <br /></td></tr>
<tr class="separator:aef275b91927e0abdc24e71807be5a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a96821fa6772092d333de442e2afd4" id="r_a91a96821fa6772092d333de442e2afd4"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a91a96821fa6772092d333de442e2afd4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91a96821fa6772092d333de442e2afd4">less_equal</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast)</td></tr>
<tr class="memdesc:a91a96821fa6772092d333de442e2afd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the ranges are equal in count and the left ranges value are all less or equal to the right ones  <br /></td></tr>
<tr class="separator:a91a96821fa6772092d333de442e2afd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a3568d020673576be1f5e80c3102eb" id="r_ab1a3568d020673576be1f5e80c3102eb"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:ab1a3568d020673576be1f5e80c3102eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1a3568d020673576be1f5e80c3102eb">greater_equal</a> (const T1 *afirst, const T1 *alast, const T2 *bfirst, const T2 *blast)</td></tr>
<tr class="memdesc:ab1a3568d020673576be1f5e80c3102eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the ranges are equal in count and the left ranges value are all greater or equal to the right ones  <br /></td></tr>
<tr class="separator:ab1a3568d020673576be1f5e80c3102eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d18a5db91c6ea30e309aab03468637" id="r_a69d18a5db91c6ea30e309aab03468637"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a69d18a5db91c6ea30e309aab03468637"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69d18a5db91c6ea30e309aab03468637">equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a69d18a5db91c6ea30e309aab03468637"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both containers have the same number of and value of elements  <br /></td></tr>
<tr class="separator:a69d18a5db91c6ea30e309aab03468637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23681fb86b52040ddd0eeeb839176eec" id="r_a23681fb86b52040ddd0eeeb839176eec"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a23681fb86b52040ddd0eeeb839176eec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23681fb86b52040ddd0eeeb839176eec">not_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a23681fb86b52040ddd0eeeb839176eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both containers do not have the same number of and value of elements  <br /></td></tr>
<tr class="separator:a23681fb86b52040ddd0eeeb839176eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6c8c4fba4c9f05ce9fe26f779dd922" id="r_a5c6c8c4fba4c9f05ce9fe26f779dd922"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a5c6c8c4fba4c9f05ce9fe26f779dd922"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c6c8c4fba4c9f05ce9fe26f779dd922">less</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5c6c8c4fba4c9f05ce9fe26f779dd922"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both containers have the same number of elements and the left one has point-wise lesser ones for all entries  <br /></td></tr>
<tr class="separator:a5c6c8c4fba4c9f05ce9fe26f779dd922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7260de3819087ef35ac07d871874e" id="r_a77a7260de3819087ef35ac07d871874e"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a77a7260de3819087ef35ac07d871874e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77a7260de3819087ef35ac07d871874e">greater</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a77a7260de3819087ef35ac07d871874e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both containers have the same number of elements and the left one has point-wise greater ones for all entries  <br /></td></tr>
<tr class="separator:a77a7260de3819087ef35ac07d871874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9953b4117f8559d68e0e132730b7dd9a" id="r_a9953b4117f8559d68e0e132730b7dd9a"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a9953b4117f8559d68e0e132730b7dd9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9953b4117f8559d68e0e132730b7dd9a">less_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9953b4117f8559d68e0e132730b7dd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both containers have the same number of elements and the left one has point-wise lesser or equal ones for all entries  <br /></td></tr>
<tr class="separator:a9953b4117f8559d68e0e132730b7dd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40149c55b3d976921a67ebbb9a811b81" id="r_a40149c55b3d976921a67ebbb9a811b81"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a40149c55b3d976921a67ebbb9a811b81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40149c55b3d976921a67ebbb9a811b81">greater_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a40149c55b3d976921a67ebbb9a811b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if both containers have the same number of elements and the left one has point-wise greater or equal ones for all entries  <br /></td></tr>
<tr class="separator:a40149c55b3d976921a67ebbb9a811b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b41076a22c83814f80942feeafc7b" id="r_afb6b41076a22c83814f80942feeafc7b"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:afb6b41076a22c83814f80942feeafc7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; bool,(N1&lt; N2) ? N1 :N2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb6b41076a22c83814f80942feeafc7b">point_wise_compare</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs, std::function&lt; bool(const T &amp;l, const T &amp;r)&gt; <a class="el" href="#acbecfc83a78e298a7740b8c6c87cdd25">compare</a>)</td></tr>
<tr class="memdesc:afb6b41076a22c83814f80942feeafc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs a point wise comparison of the <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html" title="An array of contiguous memory which is statically allocated.">StaticArrayList</a>  <br /></td></tr>
<tr class="separator:afb6b41076a22c83814f80942feeafc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae579882a3c46704e6d11c01a1600ded5" id="r_ae579882a3c46704e6d11c01a1600ded5"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:ae579882a3c46704e6d11c01a1600ded5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae579882a3c46704e6d11c01a1600ded5">point_wise_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae579882a3c46704e6d11c01a1600ded5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:ae579882a3c46704e6d11c01a1600ded5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7869f20b360ae9917160184311b1f87d" id="r_a7869f20b360ae9917160184311b1f87d"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a7869f20b360ae9917160184311b1f87d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7869f20b360ae9917160184311b1f87d">point_wise_not_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7869f20b360ae9917160184311b1f87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise un-equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:a7869f20b360ae9917160184311b1f87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c4e078e1ec33336ee42c8cd2b24f29" id="r_a05c4e078e1ec33336ee42c8cd2b24f29"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a05c4e078e1ec33336ee42c8cd2b24f29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05c4e078e1ec33336ee42c8cd2b24f29">point_wise_less</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a05c4e078e1ec33336ee42c8cd2b24f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise less list of the left and right hand side  <br /></td></tr>
<tr class="separator:a05c4e078e1ec33336ee42c8cd2b24f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3eb8a3e4437205b845b83edd917abe3" id="r_ad3eb8a3e4437205b845b83edd917abe3"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:ad3eb8a3e4437205b845b83edd917abe3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3eb8a3e4437205b845b83edd917abe3">point_wise_greater</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad3eb8a3e4437205b845b83edd917abe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise greater list of the left and right hand side  <br /></td></tr>
<tr class="separator:ad3eb8a3e4437205b845b83edd917abe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7469d1bbd5988ee0d2728f1de4dbca1a" id="r_a7469d1bbd5988ee0d2728f1de4dbca1a"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a7469d1bbd5988ee0d2728f1de4dbca1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7469d1bbd5988ee0d2728f1de4dbca1a">point_wise_less_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7469d1bbd5988ee0d2728f1de4dbca1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise less equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:a7469d1bbd5988ee0d2728f1de4dbca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3378843465b983dc475d7feaeac9be" id="r_a7a3378843465b983dc475d7feaeac9be"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a7a3378843465b983dc475d7feaeac9be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a3378843465b983dc475d7feaeac9be">point_wise_greater_equal</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7a3378843465b983dc475d7feaeac9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise greater equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:a7a3378843465b983dc475d7feaeac9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df64ddd14285cc7bb22ad03cc854c75" id="r_a9df64ddd14285cc7bb22ad03cc854c75"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a9df64ddd14285cc7bb22ad03cc854c75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9df64ddd14285cc7bb22ad03cc854c75">operator==</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9df64ddd14285cc7bb22ad03cc854c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:a9df64ddd14285cc7bb22ad03cc854c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a518469216ea461af3ee417253e20a" id="r_a29a518469216ea461af3ee417253e20a"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a29a518469216ea461af3ee417253e20a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29a518469216ea461af3ee417253e20a">operator!=</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a29a518469216ea461af3ee417253e20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise un-equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:a29a518469216ea461af3ee417253e20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a32fb35743a20e943395b7819062bd" id="r_ab0a32fb35743a20e943395b7819062bd"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:ab0a32fb35743a20e943395b7819062bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0a32fb35743a20e943395b7819062bd">operator&lt;</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab0a32fb35743a20e943395b7819062bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise less list of the left and right hand side  <br /></td></tr>
<tr class="separator:ab0a32fb35743a20e943395b7819062bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d482591de5501579e78035d23dae9ae" id="r_a1d482591de5501579e78035d23dae9ae"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a1d482591de5501579e78035d23dae9ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d482591de5501579e78035d23dae9ae">operator&gt;</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1d482591de5501579e78035d23dae9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise greater list of the left and right hand side  <br /></td></tr>
<tr class="separator:a1d482591de5501579e78035d23dae9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63ab39fd8cb11e77a330ecc8eae0860" id="r_ac63ab39fd8cb11e77a330ecc8eae0860"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:ac63ab39fd8cb11e77a330ecc8eae0860"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac63ab39fd8cb11e77a330ecc8eae0860">operator&lt;=</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac63ab39fd8cb11e77a330ecc8eae0860"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise less equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:ac63ab39fd8cb11e77a330ecc8eae0860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eabb253b910b111803e29e877794cea" id="r_a5eabb253b910b111803e29e877794cea"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1, std::size_t N2&gt; </td></tr>
<tr class="memitem:a5eabb253b910b111803e29e877794cea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5eabb253b910b111803e29e877794cea">operator&gt;=</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs, const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5eabb253b910b111803e29e877794cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the point wise greater equal list of the left and right hand side  <br /></td></tr>
<tr class="separator:a5eabb253b910b111803e29e877794cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac542a787aaa82b103fbb0de3d82b7850" id="r_ac542a787aaa82b103fbb0de3d82b7850"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1&gt; </td></tr>
<tr class="memitem:ac542a787aaa82b103fbb0de3d82b7850"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac542a787aaa82b103fbb0de3d82b7850">any</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;list)</td></tr>
<tr class="memdesc:ac542a787aaa82b103fbb0de3d82b7850"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if any (aka. at least one) values from the <code>list</code> (converted to bool) are <code>true</code>  <br /></td></tr>
<tr class="separator:ac542a787aaa82b103fbb0de3d82b7850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10e9de89496c8c5b3d7ed2f478dcb92" id="r_ab10e9de89496c8c5b3d7ed2f478dcb92"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1&gt; </td></tr>
<tr class="memitem:ab10e9de89496c8c5b3d7ed2f478dcb92"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab10e9de89496c8c5b3d7ed2f478dcb92">all</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs)</td></tr>
<tr class="memdesc:ab10e9de89496c8c5b3d7ed2f478dcb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if all values from the <code>list</code> (converted to bool) are <code>true</code>  <br /></td></tr>
<tr class="separator:ab10e9de89496c8c5b3d7ed2f478dcb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64914d60734da52ba7e9136c99ca519" id="r_af64914d60734da52ba7e9136c99ca519"><td class="memTemplParams" colspan="2">template&lt;class T, std::size_t N1&gt; </td></tr>
<tr class="memitem:af64914d60734da52ba7e9136c99ca519"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af64914d60734da52ba7e9136c99ca519">none</a> (const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;lhs)</td></tr>
<tr class="memdesc:af64914d60734da52ba7e9136c99ca519"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <code>true</code> if no values from the <code>list</code> (converted to bool) are <code>true</code>  <br /></td></tr>
<tr class="separator:af64914d60734da52ba7e9136c99ca519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30769c05e8184748d55f9ed70eb393cc" id="r_a30769c05e8184748d55f9ed70eb393cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30769c05e8184748d55f9ed70eb393cc">StaticArrayList_test</a> ()</td></tr>
<tr class="separator:a30769c05e8184748d55f9ed70eb393cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad062018b3e2ec5ee9102877c6132f5fc" id="r_ad062018b3e2ec5ee9102877c6132f5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad062018b3e2ec5ee9102877c6132f5fc">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="../../d5/d2f/classembed_1_1_exception.html">Exception</a> &amp;e)</td></tr>
<tr class="separator:ad062018b3e2ec5ee9102877c6132f5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17932d4994263ab57d2168ba020ac414" id="r_a17932d4994263ab57d2168ba020ac414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc9/definitions_8hpp.html#a08b252cdce9dc7cc5979e26c8931af0b">EMBED_WEAK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17932d4994263ab57d2168ba020ac414">disable_interrupts_command</a> ()</td></tr>
<tr class="memdesc:a17932d4994263ab57d2168ba020ac414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak, user overloadable function that provides the command to disable interrupts.  <br /></td></tr>
<tr class="separator:a17932d4994263ab57d2168ba020ac414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82d3d8858d1b2aa04e2bfc7f11ba971" id="r_ad82d3d8858d1b2aa04e2bfc7f11ba971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc9/definitions_8hpp.html#a08b252cdce9dc7cc5979e26c8931af0b">EMBED_WEAK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82d3d8858d1b2aa04e2bfc7f11ba971">enable_interrupts_command</a> ()</td></tr>
<tr class="memdesc:ad82d3d8858d1b2aa04e2bfc7f11ba971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak, user overloadable function that probides the command to enable interrupts.  <br /></td></tr>
<tr class="separator:ad82d3d8858d1b2aa04e2bfc7f11ba971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94940e93c424da8f4b0832585c298e50" id="r_a94940e93c424da8f4b0832585c298e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94940e93c424da8f4b0832585c298e50">disable_interrupts</a> ()</td></tr>
<tr class="memdesc:a94940e93c424da8f4b0832585c298e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that is used to disable the interrupts.  <br /></td></tr>
<tr class="separator:a94940e93c424da8f4b0832585c298e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20267fb3069e1a33fc6967d3d1fd6bc" id="r_af20267fb3069e1a33fc6967d3d1fd6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af20267fb3069e1a33fc6967d3d1fd6bc">enable_interrupts</a> ()</td></tr>
<tr class="memdesc:af20267fb3069e1a33fc6967d3d1fd6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer that is used to enable the interrupts.  <br /></td></tr>
<tr class="separator:af20267fb3069e1a33fc6967d3d1fd6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4f6a3d44543a027f1e2c082f441126" id="r_aff4f6a3d44543a027f1e2c082f441126"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff4f6a3d44543a027f1e2c082f441126">frexp10</a> (float value, int *exp10_out)</td></tr>
<tr class="separator:aff4f6a3d44543a027f1e2c082f441126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8910e9ca60ee5596303fc617b92fccd" id="r_aa8910e9ca60ee5596303fc617b92fccd"><td class="memTemplParams" colspan="2">template&lt;typename Int, typename std::enable_if&lt; std::is_integral&lt; Int &gt;::value, int &gt;::type = 0&gt; </td></tr>
<tr class="memitem:aa8910e9ca60ee5596303fc617b92fccd"><td class="memTemplItemLeft" align="right" valign="top">constexpr Int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8910e9ca60ee5596303fc617b92fccd">pow</a> (const Int base, const unsigned int exponent)</td></tr>
<tr class="separator:aa8910e9ca60ee5596303fc617b92fccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e9c37cca170435a19572f0d4e78e3a" id="r_aa8e9c37cca170435a19572f0d4e78e3a"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8e9c37cca170435a19572f0d4e78e3a">string_length</a> (const char *str)</td></tr>
<tr class="memdesc:aa8e9c37cca170435a19572f0d4e78e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the length of a terminated c-style string  <br /></td></tr>
<tr class="separator:aa8e9c37cca170435a19572f0d4e78e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dbc4d9e568dd8f49796585866d083d" id="r_af0dbc4d9e568dd8f49796585866d083d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0dbc4d9e568dd8f49796585866d083d">is_nan</a> (float value)</td></tr>
<tr class="separator:af0dbc4d9e568dd8f49796585866d083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd776e8fcb055db77d25a5378dd14e16" id="r_afd776e8fcb055db77d25a5378dd14e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd776e8fcb055db77d25a5378dd14e16">is_pinf</a> (float value)</td></tr>
<tr class="separator:afd776e8fcb055db77d25a5378dd14e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac368b64120fc9895d53b20d4d57335f" id="r_aac368b64120fc9895d53b20d4d57335f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac368b64120fc9895d53b20d4d57335f">is_ninf</a> (float value)</td></tr>
<tr class="separator:aac368b64120fc9895d53b20d4d57335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c99f01dff3225a8a8ea946efb70926e" id="r_a2c99f01dff3225a8a8ea946efb70926e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c99f01dff3225a8a8ea946efb70926e">is_inf</a> (float value)</td></tr>
<tr class="separator:a2c99f01dff3225a8a8ea946efb70926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe0ff1b58799ddf5953a9f0ab47cfc1" id="r_aebe0ff1b58799ddf5953a9f0ab47cfc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe0ff1b58799ddf5953a9f0ab47cfc1">_memcpy</a> (void *dest, const void *source, size_t count)</td></tr>
<tr class="memdesc:aebe0ff1b58799ddf5953a9f0ab47cfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies count many bytes from <code>source</code> to <code>dest</code> in a blocking behaviour.  <br /></td></tr>
<tr class="separator:aebe0ff1b58799ddf5953a9f0ab47cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b9edb4fe2c28190616bdc7d71861d" id="r_a704b9edb4fe2c28190616bdc7d71861d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704b9edb4fe2c28190616bdc7d71861d">_async_memcpy</a> (void *dest, const void *source, size_t count, <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt; promise)</td></tr>
<tr class="memdesc:a704b9edb4fe2c28190616bdc7d71861d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies count many bytes from <code>source</code> to <code>dest</code> in a blocking behaviour.  <br /></td></tr>
<tr class="separator:a704b9edb4fe2c28190616bdc7d71861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aef787367fcd2d3d3bac830e61174c6" id="r_a0aef787367fcd2d3d3bac830e61174c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0aef787367fcd2d3d3bac830e61174c6">memcpy_s</a> (void *dest, size_t destSize, const void *source, size_t sourceSize)</td></tr>
<tr class="memdesc:a0aef787367fcd2d3d3bac830e61174c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies from source to dest so that no more bytes than destSize or sourceSize are written  <br /></td></tr>
<tr class="separator:a0aef787367fcd2d3d3bac830e61174c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348183f304efebc2fa669e9e0edb1976" id="r_a348183f304efebc2fa669e9e0edb1976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a348183f304efebc2fa669e9e0edb1976">memcpy_s</a> (void *destFirst, void *destLast, const void *sourceFirst, const void *sourceLast)</td></tr>
<tr class="memdesc:a348183f304efebc2fa669e9e0edb1976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from source to dest, without leaving the closed open range [first, last)  <br /></td></tr>
<tr class="separator:a348183f304efebc2fa669e9e0edb1976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfef4733fb9c8869140d4acb0252628" id="r_a3dfef4733fb9c8869140d4acb0252628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dfef4733fb9c8869140d4acb0252628">async_memcpy_s</a> (void *dest, size_t destSize, const void *source, size_t sourceSize, <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt; promise)</td></tr>
<tr class="separator:a3dfef4733fb9c8869140d4acb0252628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1978f432d556a2358f47ef336c63c4fb" id="r_a1978f432d556a2358f47ef336c63c4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1978f432d556a2358f47ef336c63c4fb">async_memcpy_s</a> (void *destFirst, void *destLast, const void *sourceFirst, const void *sourceLast, <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt; promise)</td></tr>
<tr class="separator:a1978f432d556a2358f47ef336c63c4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad866fb7cc44f6f1fa85fcb416676d05d" id="r_ad866fb7cc44f6f1fa85fcb416676d05d"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral UInt, CStdRatio Period = std::ratio&lt;1&gt;, UInt MaxTick = std::numeric_limits&lt;UInt&gt;::max()&gt; </td></tr>
<tr class="memitem:ad866fb7cc44f6f1fa85fcb416676d05d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad866fb7cc44f6f1fa85fcb416676d05d">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f">Duration</a>&lt; UInt, Period, MaxTick &gt; &amp;duration)</td></tr>
<tr class="separator:ad866fb7cc44f6f1fa85fcb416676d05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce5bdc89df2cf8eca7fb6b325122c4b" id="r_a9ce5bdc89df2cf8eca7fb6b325122c4b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, std::unsigned_integral UInt = Clock::value_type, CStdRatio Period = Clock::period, UInt MaxTick = Clock::max_tick&gt; </td></tr>
<tr class="memitem:a9ce5bdc89df2cf8eca7fb6b325122c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ce5bdc89df2cf8eca7fb6b325122c4b">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="#af176ead949b706e7d5afcb8ddb67b543">TimePoint</a>&lt; <a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, UInt, Period, MaxTick &gt; &amp;tp)</td></tr>
<tr class="separator:a9ce5bdc89df2cf8eca7fb6b325122c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8afd0567c76141cbfd1fd2d9833ec3" id="r_a4d8afd0567c76141cbfd1fd2d9833ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d8afd0567c76141cbfd1fd2d9833ec3">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, <a class="el" href="#ae2cdc9f9929967b62dfcec7be0e6c2f1">Exit</a> value)</td></tr>
<tr class="separator:a4d8afd0567c76141cbfd1fd2d9833ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec82ecae8adedfd3652fdad9835931c7" id="r_aec82ecae8adedfd3652fdad9835931c7"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:aec82ecae8adedfd3652fdad9835931c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec82ecae8adedfd3652fdad9835931c7">make_future_promise</a> ()</td></tr>
<tr class="memdesc:aec82ecae8adedfd3652fdad9835931c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a linked future promise pair  <br /></td></tr>
<tr class="separator:aec82ecae8adedfd3652fdad9835931c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ee8549b969e0ec1355b46484a30ee5" id="r_a78ee8549b969e0ec1355b46484a30ee5"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T&gt; </td></tr>
<tr class="memitem:a78ee8549b969e0ec1355b46484a30ee5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78ee8549b969e0ec1355b46484a30ee5">get</a> (<a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">embed::FuturePromisePair</a>&lt; T &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a78ee8549b969e0ec1355b46484a30ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b2bd334fe44c7c8bf1f710ff0c2ce9" id="r_a62b2bd334fe44c7c8bf1f710ff0c2ce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b2bd334fe44c7c8bf1f710ff0c2ce9">add_task</a> (<a class="el" href="../../d8/d46/classembed_1_1_co_task.html">CoTask</a> *task)</td></tr>
<tr class="separator:a62b2bd334fe44c7c8bf1f710ff0c2ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae443a3070e85e0878e665ccf0d73f9d1" id="r_ae443a3070e85e0878e665ccf0d73f9d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae443a3070e85e0878e665ccf0d73f9d1">spin</a> ()</td></tr>
<tr class="separator:ae443a3070e85e0878e665ccf0d73f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e30ea59b81aa27862451e84c9da3501" id="r_a0e30ea59b81aa27862451e84c9da3501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e30ea59b81aa27862451e84c9da3501">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="../../dc/d23/structembed_1_1_format_str.html">FormatStr</a> &amp;fstr)</td></tr>
<tr class="memdesc:a0e30ea59b81aa27862451e84c9da3501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <code><a class="el" href="../../dc/d23/structembed_1_1_format_str.html" title="Formats a string and allows to pass an additional size parameter.">FormatStr</a></code> to the stream that allows to pass the string length in addition to the <code>const char*</code> type string.  <br /></td></tr>
<tr class="separator:a0e30ea59b81aa27862451e84c9da3501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa739db9084a3ca2490b87a922fd585f6" id="r_aa739db9084a3ca2490b87a922fd585f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa739db9084a3ca2490b87a922fd585f6">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="../../d8/d02/structembed_1_1_format_bool.html">FormatBool</a> &amp;value)</td></tr>
<tr class="memdesc:aa739db9084a3ca2490b87a922fd585f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a bool to the output stream and applies custom formating.  <br /></td></tr>
<tr class="separator:aa739db9084a3ca2490b87a922fd585f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54c87644e42197a01ceb09991ff8979" id="r_ae54c87644e42197a01ceb09991ff8979"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae54c87644e42197a01ceb09991ff8979">str_add_uint</a> (char *first, char const *last, std::make_unsigned_t&lt; <a class="el" href="../../d7/d25/structembed_1_1_format_int.html#aba93e6faa9c923ded7675fa6ae624a72">FormatInt::value_type</a> &gt; value, const <a class="el" href="../../d4/dba/structembed_1_1str__add__uint__params.html">str_add_uint_params</a> &amp;params)</td></tr>
<tr class="separator:ae54c87644e42197a01ceb09991ff8979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b921f60de08b5ce3af95a2a78e1618d" id="r_a5b921f60de08b5ce3af95a2a78e1618d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b921f60de08b5ce3af95a2a78e1618d">str_add_sint</a> (char *first, char const *last, <a class="el" href="../../d7/d25/structembed_1_1_format_int.html#aba93e6faa9c923ded7675fa6ae624a72">FormatInt::value_type</a> value, const <a class="el" href="../../d4/dba/structembed_1_1str__add__uint__params.html">str_add_uint_params</a> &amp;params)</td></tr>
<tr class="separator:a5b921f60de08b5ce3af95a2a78e1618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae653f2b9b9c8a42a244d7bb76cedb35d" id="r_ae653f2b9b9c8a42a244d7bb76cedb35d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae653f2b9b9c8a42a244d7bb76cedb35d">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const <a class="el" href="../../d7/d25/structembed_1_1_format_int.html">FormatInt</a> &amp;fvalue)</td></tr>
<tr class="memdesc:ae653f2b9b9c8a42a244d7bb76cedb35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints integers to streams with a certain format.  <br /></td></tr>
<tr class="separator:ae653f2b9b9c8a42a244d7bb76cedb35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47d782f80fabf223abf14752f6fb3d" id="r_a5f47d782f80fabf223abf14752f6fb3d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f47d782f80fabf223abf14752f6fb3d">str_add_float</a> (char *first, const char *last, const <a class="el" href="../../d8/d05/structembed_1_1_format_float.html">FormatFloat</a> &amp;value)</td></tr>
<tr class="separator:a5f47d782f80fabf223abf14752f6fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e984c6721dcdf20c2e831160b75484" id="r_af5e984c6721dcdf20c2e831160b75484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e984c6721dcdf20c2e831160b75484">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, <a class="el" href="../../d8/d05/structembed_1_1_format_float.html">FormatFloat</a> value)</td></tr>
<tr class="separator:af5e984c6721dcdf20c2e831160b75484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f31cf9cfc65dac727a6c8985677efc" id="r_a90f31cf9cfc65dac727a6c8985677efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f31cf9cfc65dac727a6c8985677efc">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, std::chrono::nanoseconds value)</td></tr>
<tr class="separator:a90f31cf9cfc65dac727a6c8985677efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820596136806116345e7b29ad64a06e6" id="r_a820596136806116345e7b29ad64a06e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a820596136806116345e7b29ad64a06e6">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, std::chrono::microseconds value)</td></tr>
<tr class="separator:a820596136806116345e7b29ad64a06e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4636e466b73a553d3c87828d88bcac4b" id="r_a4636e466b73a553d3c87828d88bcac4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4636e466b73a553d3c87828d88bcac4b">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, std::chrono::milliseconds value)</td></tr>
<tr class="separator:a4636e466b73a553d3c87828d88bcac4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591095b1cd7b3b24d84a7aec2074b7e8" id="r_a591095b1cd7b3b24d84a7aec2074b7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591095b1cd7b3b24d84a7aec2074b7e8">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, std::chrono::seconds value)</td></tr>
<tr class="separator:a591095b1cd7b3b24d84a7aec2074b7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea56d0d8ed2777f351446d35730e484" id="r_aaea56d0d8ed2777f351446d35730e484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaea56d0d8ed2777f351446d35730e484">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, std::chrono::minutes value)</td></tr>
<tr class="separator:aaea56d0d8ed2777f351446d35730e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234c0b40a4641ebcd1ddb97909dd1468" id="r_a234c0b40a4641ebcd1ddb97909dd1468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a234c0b40a4641ebcd1ddb97909dd1468">newl</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream)</td></tr>
<tr class="memdesc:a234c0b40a4641ebcd1ddb97909dd1468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new line character to the stream.  <br /></td></tr>
<tr class="separator:a234c0b40a4641ebcd1ddb97909dd1468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849324c8a3c7cfafacc495323a2a2386" id="r_a849324c8a3c7cfafacc495323a2a2386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a849324c8a3c7cfafacc495323a2a2386">flush</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream)</td></tr>
<tr class="memdesc:a849324c8a3c7cfafacc495323a2a2386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new line character to the stream.  <br /></td></tr>
<tr class="separator:a849324c8a3c7cfafacc495323a2a2386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be0779e7c838af9fabe0cf2d3bd34b" id="r_aa1be0779e7c838af9fabe0cf2d3bd34b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1be0779e7c838af9fabe0cf2d3bd34b">endl</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream)</td></tr>
<tr class="memdesc:aa1be0779e7c838af9fabe0cf2d3bd34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new line character to the stream followed by a call to <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html#acd3cef8a72e71ea2d8d15a1275cbb480" title="Overload this method to force flush the buffer.">OStream::flush()</a>  <br /></td></tr>
<tr class="separator:aa1be0779e7c838af9fabe0cf2d3bd34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55444c8c42d892d8dce9369bb61dcbf" id="r_ae55444c8c42d892d8dce9369bb61dcbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae55444c8c42d892d8dce9369bb61dcbf">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, void(*function)(<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;))</td></tr>
<tr class="memdesc:ae55444c8c42d892d8dce9369bb61dcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function with the stream as the argument.  <br /></td></tr>
<tr class="separator:ae55444c8c42d892d8dce9369bb61dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea3950d85e2687a040672c64da707ad" id="r_a9ea3950d85e2687a040672c64da707ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea3950d85e2687a040672c64da707ad">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, char c)</td></tr>
<tr class="memdesc:a9ea3950d85e2687a040672c64da707ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a char to the stream.  <br /></td></tr>
<tr class="separator:a9ea3950d85e2687a040672c64da707ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612f772633b86468b9f21e296ee7b4c7" id="r_a612f772633b86468b9f21e296ee7b4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a612f772633b86468b9f21e296ee7b4c7">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const char *str)</td></tr>
<tr class="memdesc:a612f772633b86468b9f21e296ee7b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes a terminated c-style string to the stream  <br /></td></tr>
<tr class="separator:a612f772633b86468b9f21e296ee7b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd68bda525710bbc6bb8790456bd6a" id="r_ac1bd68bda525710bbc6bb8790456bd6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1bd68bda525710bbc6bb8790456bd6a">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, bool value)</td></tr>
<tr class="memdesc:ac1bd68bda525710bbc6bb8790456bd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default bool formating, uses the settings of the stream.  <br /></td></tr>
<tr class="separator:ac1bd68bda525710bbc6bb8790456bd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14d30c7afbdb340c36e85dbb0876e9b" id="r_aa14d30c7afbdb340c36e85dbb0876e9b"><td class="memTemplParams" colspan="2">template&lt;typename Int, typename std::enable_if&lt; std::is_integral&lt; Int &gt;::value, int &gt;::type = 0&gt; </td></tr>
<tr class="memitem:aa14d30c7afbdb340c36e85dbb0876e9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa14d30c7afbdb340c36e85dbb0876e9b">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const Int &amp;value)</td></tr>
<tr class="separator:aa14d30c7afbdb340c36e85dbb0876e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d648bf3139d52abbf1c5a3981fdf6b" id="r_a75d648bf3139d52abbf1c5a3981fdf6b"><td class="memTemplParams" colspan="2">template&lt;typename Float, typename std::enable_if&lt; std::is_floating_point&lt; Float &gt;::value, int &gt;::type = 0&gt; </td></tr>
<tr class="memitem:a75d648bf3139d52abbf1c5a3981fdf6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75d648bf3139d52abbf1c5a3981fdf6b">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, Float value)</td></tr>
<tr class="separator:a75d648bf3139d52abbf1c5a3981fdf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e8046410d09a4d314f1a58496ca15b" id="r_a41e8046410d09a4d314f1a58496ca15b"><td class="memTemplParams" colspan="2">template&lt;std::unsigned_integral UInt&gt; </td></tr>
<tr class="memitem:a41e8046410d09a4d314f1a58496ca15b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41e8046410d09a4d314f1a58496ca15b">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, <a class="el" href="../../d4/d27/structembed_1_1_format_hex.html">FormatHex</a>&lt; UInt &gt; hex)</td></tr>
<tr class="separator:a41e8046410d09a4d314f1a58496ca15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb659d1ae70230815733bbf5adc92fc" id="r_a7eb659d1ae70230815733bbf5adc92fc"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a7eb659d1ae70230815733bbf5adc92fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7eb659d1ae70230815733bbf5adc92fc">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, const T *ptr)</td></tr>
<tr class="separator:a7eb659d1ae70230815733bbf5adc92fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb360b366a0f258534229ac0bf4cd94" id="r_a4cb360b366a0f258534229ac0bf4cd94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb360b366a0f258534229ac0bf4cd94">operator&lt;&lt;</a> (<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;stream, std::nullptr_t ptr)</td></tr>
<tr class="separator:a4cb360b366a0f258534229ac0bf4cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a193507bf7b99407e04962553bbec80" id="r_a9a193507bf7b99407e04962553bbec80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a193507bf7b99407e04962553bbec80">print_failed_function_file_line</a> (const char *signature, const char *file, std::size_t line)</td></tr>
<tr class="separator:a9a193507bf7b99407e04962553bbec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bbbc388849cd0a33bf019eba6d4195" id="r_a90bbbc388849cd0a33bf019eba6d4195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90bbbc388849cd0a33bf019eba6d4195">TEST_FUNC_print_1</a> (const char *signature, const char *file, std::size_t line, const char *test_func, const char *val_str)</td></tr>
<tr class="separator:a90bbbc388849cd0a33bf019eba6d4195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ab1e1233cdbe06f6f3c85c4306e8c" id="r_af36ab1e1233cdbe06f6f3c85c4306e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36ab1e1233cdbe06f6f3c85c4306e8c">TEST_FUNC2_print_1</a> (const char *signature, const char *file, std::size_t line, const char *test_func, const char *lhs_str, const char *rhs_str)</td></tr>
<tr class="separator:af36ab1e1233cdbe06f6f3c85c4306e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3915dc5b7472a01c0c6a9ac77755c8f8" id="r_a3915dc5b7472a01c0c6a9ac77755c8f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3915dc5b7472a01c0c6a9ac77755c8f8">TEST_BINARY_OPERATOR_print_1</a> (const char *signature, const char *file, std::size_t line, const char *lhs_str, const char *op, const char *rhs_str)</td></tr>
<tr class="separator:a3915dc5b7472a01c0c6a9ac77755c8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf4b09069973db1435ed1a7e376998f" id="r_abcf4b09069973db1435ed1a7e376998f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcf4b09069973db1435ed1a7e376998f">TEST_NOT_BINARY_OPERATOR_print_1</a> (const char *signature, const char *file, std::size_t line, const char *lhs_str, const char *op, const char *rhs_str)</td></tr>
<tr class="separator:abcf4b09069973db1435ed1a7e376998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843685ca669191c0afc770417808951e" id="r_a843685ca669191c0afc770417808951e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a843685ca669191c0afc770417808951e">TEST_TRUE_print_1</a> (const char *signature, const char *file, std::size_t line, const char *val)</td></tr>
<tr class="separator:a843685ca669191c0afc770417808951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2417f212fa0f80e6b81f7d9270959496" id="r_a2417f212fa0f80e6b81f7d9270959496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2417f212fa0f80e6b81f7d9270959496">TEST_FALSE_print_1</a> (const char *signature, const char *file, std::size_t line, const char *val)</td></tr>
<tr class="separator:a2417f212fa0f80e6b81f7d9270959496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ddba714d37caded1c35736a02bacf9" id="r_ad3ddba714d37caded1c35736a02bacf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ddba714d37caded1c35736a02bacf9">TEST_ERROR_print</a> (const char *signature, const char *file, std::size_t line)</td></tr>
<tr class="separator:ad3ddba714d37caded1c35736a02bacf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b4b90d82c02e85d9cf8799d56572ba" id="r_a54b4b90d82c02e85d9cf8799d56572ba"><td class="memTemplParams" colspan="2">template&lt;class T, class R&gt; </td></tr>
<tr class="memitem:a54b4b90d82c02e85d9cf8799d56572ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54b4b90d82c02e85d9cf8799d56572ba">TEST_FUNC_print_2</a> (const char *test_func, const T &amp;val, const R &amp;result)</td></tr>
<tr class="separator:a54b4b90d82c02e85d9cf8799d56572ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef5615d55f198e96559f877f447f04d" id="r_adef5615d55f198e96559f877f447f04d"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, class R&gt; </td></tr>
<tr class="memitem:adef5615d55f198e96559f877f447f04d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adef5615d55f198e96559f877f447f04d">TEST_FUNC2_print_2</a> (const char *test_func, const T1 &amp;lhs, const T2 &amp;rhs, const R &amp;result)</td></tr>
<tr class="separator:adef5615d55f198e96559f877f447f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f2e8b6b26ac401a1fcf9790cf170ef" id="r_a74f2e8b6b26ac401a1fcf9790cf170ef"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, class R&gt; </td></tr>
<tr class="memitem:a74f2e8b6b26ac401a1fcf9790cf170ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74f2e8b6b26ac401a1fcf9790cf170ef">TEST_BINARY_OPERATOR_print_2</a> (const T1 &amp;lhs, const char *op, const T2 &amp;rhs, const R &amp;result)</td></tr>
<tr class="separator:a74f2e8b6b26ac401a1fcf9790cf170ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a4e6880e0a5dbd26be6b864c4c394a" id="r_ab8a4e6880e0a5dbd26be6b864c4c394a"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2, class R&gt; </td></tr>
<tr class="memitem:ab8a4e6880e0a5dbd26be6b864c4c394a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8a4e6880e0a5dbd26be6b864c4c394a">TEST_NOT_BINARY_OPERATOR_print_2</a> (const T1 &amp;lhs, const char *op, const T2 &amp;rhs, const R &amp;result)</td></tr>
<tr class="separator:ab8a4e6880e0a5dbd26be6b864c4c394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bfba877881d87f939c2604260c9713" id="r_af7bfba877881d87f939c2604260c9713"><td class="memTemplParams" colspan="2">template&lt;class R&gt; </td></tr>
<tr class="memitem:af7bfba877881d87f939c2604260c9713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7bfba877881d87f939c2604260c9713">TEST_TRUE_print_2</a> (const R &amp;val)</td></tr>
<tr class="separator:af7bfba877881d87f939c2604260c9713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf709b040cc89ae4be7157b18c22686" id="r_a5cf709b040cc89ae4be7157b18c22686"><td class="memTemplParams" colspan="2">template&lt;class R&gt; </td></tr>
<tr class="memitem:a5cf709b040cc89ae4be7157b18c22686"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cf709b040cc89ae4be7157b18c22686">TEST_FALSE_print_2</a> (const R &amp;val)</td></tr>
<tr class="separator:a5cf709b040cc89ae4be7157b18c22686"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6110642d9057733c6e33a62b37d6a0be" id="r_a6110642d9057733c6e33a62b37d6a0be"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a6110642d9057733c6e33a62b37d6a0be"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6110642d9057733c6e33a62b37d6a0be">is_std_ratio_v</a> = <a class="el" href="../../d5/d2d/structembed_1_1is__std__ratio.html">is_std_ratio</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6110642d9057733c6e33a62b37d6a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0c5bef22c932ba22122839e2dff182" id="r_a3e0c5bef22c932ba22122839e2dff182"><td class="memItemLeft" align="right" valign="top">static std::atomic&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e0c5bef22c932ba22122839e2dff182">_irq_disable_count</a> {0}</td></tr>
<tr class="separator:a3e0c5bef22c932ba22122839e2dff182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca9b6603fe5654bfda9f78552324031" id="r_afca9b6603fe5654bfda9f78552324031"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca9b6603fe5654bfda9f78552324031">memcpy</a> )(void *dest, const void *source, size_t count) = <a class="el" href="#aebe0ff1b58799ddf5953a9f0ab47cfc1">_memcpy</a></td></tr>
<tr class="memdesc:afca9b6603fe5654bfda9f78552324031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that the embed:: library uses to copy memory.  <br /></td></tr>
<tr class="separator:afca9b6603fe5654bfda9f78552324031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6263c5b80970cfebe199a039d85eebca" id="r_a6263c5b80970cfebe199a039d85eebca"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6263c5b80970cfebe199a039d85eebca">async_memcpy</a> )(void *dest, const void *source, size_t count, <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt; promise) = <a class="el" href="#a704b9edb4fe2c28190616bdc7d71861d">_async_memcpy</a></td></tr>
<tr class="memdesc:a6263c5b80970cfebe199a039d85eebca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that the embed library uses to copy memory.  <br /></td></tr>
<tr class="separator:a6263c5b80970cfebe199a039d85eebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dcf29ad44042bbb681118a6c6fe885" id="r_a12dcf29ad44042bbb681118a6c6fe885"><td class="memItemLeft" align="right" valign="top">std::pmr::memory_resource *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12dcf29ad44042bbb681118a6c6fe885">coroutine_frame_allocator</a> = nullptr</td></tr>
<tr class="separator:a12dcf29ad44042bbb681118a6c6fe885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0196bffb98599840f820f09d867d7b" id="r_a2b0196bffb98599840f820f09d867d7b"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="../../dd/d78/classembed_1_1_i_scheduler.html">embed::IScheduler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b0196bffb98599840f820f09d867d7b">CoTask</a></td></tr>
<tr class="separator:a2b0196bffb98599840f820f09d867d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eb85d54a5d35d962cd15d7e334de96" id="r_a53eb85d54a5d35d962cd15d7e334de96"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="../../dd/d78/classembed_1_1_i_scheduler.html">embed::IScheduler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53eb85d54a5d35d962cd15d7e334de96">task_list</a></td></tr>
<tr class="separator:a53eb85d54a5d35d962cd15d7e334de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b081abf25eac7c5df285045f3baa3a" id="r_a09b081abf25eac7c5df285045f3baa3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b081abf25eac7c5df285045f3baa3a">cout</a></td></tr>
<tr class="separator:a09b081abf25eac7c5df285045f3baa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920dea94b29d748d0759ba99100b3a98" id="r_a920dea94b29d748d0759ba99100b3a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a920dea94b29d748d0759ba99100b3a98">cerr</a></td></tr>
<tr class="separator:a920dea94b29d748d0759ba99100b3a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6d4fa59dda37fb0bc6611627faa99" id="r_ac0d6d4fa59dda37fb0bc6611627faa99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d6d4fa59dda37fb0bc6611627faa99">clog</a></td></tr>
<tr class="separator:ac0d6d4fa59dda37fb0bc6611627faa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1207d2a54eaeadbbc382caa0ee84a5" id="r_aca1207d2a54eaeadbbc382caa0ee84a5"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca1207d2a54eaeadbbc382caa0ee84a5">expected_true_but</a> = &quot; expected `true` but: `&quot;</td></tr>
<tr class="separator:aca1207d2a54eaeadbbc382caa0ee84a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470bd266c8aae5c833cb5e3dc2ab07c9" id="r_a470bd266c8aae5c833cb5e3dc2ab07c9"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a470bd266c8aae5c833cb5e3dc2ab07c9">expected_false_but</a> = &quot; expected `false` but: `&quot;</td></tr>
<tr class="separator:a470bd266c8aae5c833cb5e3dc2ab07c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cab50e4b835dc811b9cb686b41bbb4" id="r_a30cab50e4b835dc811b9cb686b41bbb4"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30cab50e4b835dc811b9cb686b41bbb4">indented_arrow</a> = &quot; --&gt; `&quot;</td></tr>
<tr class="separator:a30cab50e4b835dc811b9cb686b41bbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0223e2bd607a0788b0c7955a65dfe73f" name="a0223e2bd607a0788b0c7955a65dfe73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0223e2bd607a0788b0c7955a65dfe73f">&#9670;&#160;</a></span>Duration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral UInt, CStdRatio Period = std::ratio&lt;1&gt;, UInt MaxTick = std::numeric_limits&lt;UInt&gt;::max()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f">embed::Duration</a> = std::chrono::duration&lt;<a class="el" href="../../d3/d21/classembed_1_1_clock_tick.html">ClockTick</a>&lt;UInt, MaxTick&gt;, Period&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overflow aware time duration type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UInt</td><td>The underlieing integral type for the counter </td></tr>
    <tr><td class="paramname">MaxTick</td><td>Maximum distance before timer overflow </td></tr>
    <tr><td class="paramname">Period</td><td>std::ratio to 1s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af176ead949b706e7d5afcb8ddb67b543" name="af176ead949b706e7d5afcb8ddb67b543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af176ead949b706e7d5afcb8ddb67b543">&#9670;&#160;</a></span>TimePoint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, std::unsigned_integral UInt = Clock::value_type, CStdRatio Period = Clock::period, UInt MaxTick = Clock::max_tick&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af176ead949b706e7d5afcb8ddb67b543">embed::TimePoint</a> = std::chrono::time_point&lt;<a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, <a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f">Duration</a>&lt;UInt, Period, MaxTick&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overflow aware time point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="../../da/d86/structembed_1_1_clock.html" title="A template for an overflow aware clock type for the use with TimePoint">Clock</a></td><td>The clock this time point referes to </td></tr>
    <tr><td class="paramname">UInt</td><td>The underlieing integral type for the counter </td></tr>
    <tr><td class="paramname">MaxTick</td><td>Maximum distance before timer overflow </td></tr>
    <tr><td class="paramname">Period</td><td>Period std::ratio to 1s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8caae6bd6b5d592b288dfcf439e8b326" name="a8caae6bd6b5d592b288dfcf439e8b326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8caae6bd6b5d592b288dfcf439e8b326">&#9670;&#160;</a></span>AlignmentLRC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8caae6bd6b5d592b288dfcf439e8b326">embed::AlignmentLRC</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8caae6bd6b5d592b288dfcf439e8b326a945d5e233cf7d6240f6b783b36a374ff" name="a8caae6bd6b5d592b288dfcf439e8b326a945d5e233cf7d6240f6b783b36a374ff"></a>Left&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8caae6bd6b5d592b288dfcf439e8b326a92b09c7c48c520c3c55e497875da437c" name="a8caae6bd6b5d592b288dfcf439e8b326a92b09c7c48c520c3c55e497875da437c"></a>Right&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8caae6bd6b5d592b288dfcf439e8b326a4f1f6016fc9f3f2353c0cc7c67b292bd" name="a8caae6bd6b5d592b288dfcf439e8b326a4f1f6016fc9f3f2353c0cc7c67b292bd"></a>Center&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae2cdc9f9929967b62dfcec7be0e6c2f1" name="ae2cdc9f9929967b62dfcec7be0e6c2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cdc9f9929967b62dfcec7be0e6c2f1">&#9670;&#160;</a></span>Exit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ae2cdc9f9929967b62dfcec7be0e6c2f1">embed::Exit</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae2cdc9f9929967b62dfcec7be0e6c2f1a505a83f220c02df2f85c3810cd9ceb38" name="ae2cdc9f9929967b62dfcec7be0e6c2f1a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"><p>Task completed successfully; destroy it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae2cdc9f9929967b62dfcec7be0e6c2f1ae139a585510a502bbf1841cf589f5086" name="ae2cdc9f9929967b62dfcec7be0e6c2f1ae139a585510a502bbf1841cf589f5086"></a>Failure&#160;</td><td class="fielddoc"><p>Task failed; notify or destroy. </p>
</td></tr>
</table>

</div>
</div>
<a id="a22ce549beb48db3ec13fd89ecd7c333d" name="a22ce549beb48db3ec13fd89ecd7c333d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ce549beb48db3ec13fd89ecd7c333d">&#9670;&#160;</a></span>FloatRepresentation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a22ce549beb48db3ec13fd89ecd7c333d">embed::FloatRepresentation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to specify the formating of floating point numbers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a22ce549beb48db3ec13fd89ecd7c333da21234a0e100d74037a4da2e53f3200d7" name="a22ce549beb48db3ec13fd89ecd7c333da21234a0e100d74037a4da2e53f3200d7"></a>Scientific&#160;</td><td class="fielddoc"><p>numbers are represented, so that there is always only one digit before the comma. E.g.: 1.23, 1.23e+1, 1.23e+2, 1.23e+3 </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ce549beb48db3ec13fd89ecd7c333daab0268fb8036a892dc341945cb7ae3be" name="a22ce549beb48db3ec13fd89ecd7c333daab0268fb8036a892dc341945cb7ae3be"></a>Engineering&#160;</td><td class="fielddoc"><p>numbers are represented with exponents in order or three. E.g.: 1.23, 12.3, 123e, 1.23e+3 </p>
</td></tr>
<tr><td class="fieldname"><a id="a22ce549beb48db3ec13fd89ecd7c333dabbd47109890259c0127154db1af26c75" name="a22ce549beb48db3ec13fd89ecd7c333dabbd47109890259c0127154db1af26c75"></a>Full&#160;</td><td class="fielddoc"><p>numbers are represented fully without exponents. E.g.: 1.23, 12.3, 123., 1230 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a704b9edb4fe2c28190616bdc7d71861d" name="a704b9edb4fe2c28190616bdc7d71861d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704b9edb4fe2c28190616bdc7d71861d">&#9670;&#160;</a></span>_async_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::_async_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies count many bytes from <code>source</code> to <code>dest</code> in a blocking behaviour. </p>
<p>Internal/default implementation for <a class="el" href="#a6263c5b80970cfebe199a039d85eebca" title="Function that the embed library uses to copy memory.">embed::async_memcpy</a> that the embed library uses to copy data. Redirect the <code><a class="el" href="#afca9b6603fe5654bfda9f78552324031" title="Function that the embed:: library uses to copy memory.">embed::memcpy</a></code> and <code><a class="el" href="#a6263c5b80970cfebe199a039d85eebca" title="Function that the embed library uses to copy memory.">embed::async_memcpy</a></code> function pinters to overload it with your custom copy implementation, that for example uses a direct memory access controller (DMA).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination to which <code>count</code> many bytes will be written </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source from which <code>count</code> many bytes will be read </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be copied </td></tr>
    <tr><td class="paramname">promise</td><td>The caller will generate a <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> that stores a future value. From which this promise is derived. The <a class="el" href="../../de/dd8/classembed_1_1_promise.html" title="Promise and Future pairs are used to synchronise values between asynchronous tasks.">Promise</a> will signal to the future when the asynchrunous operation completed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebe0ff1b58799ddf5953a9f0ab47cfc1" name="aebe0ff1b58799ddf5953a9f0ab47cfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe0ff1b58799ddf5953a9f0ab47cfc1">&#9670;&#160;</a></span>_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies count many bytes from <code>source</code> to <code>dest</code> in a blocking behaviour. </p>
<p>Internal/default implementation for <a class="el" href="#afca9b6603fe5654bfda9f78552324031" title="Function that the embed:: library uses to copy memory.">embed::memcpy</a> that the embed library uses to copy data. Redirect the <code><a class="el" href="#afca9b6603fe5654bfda9f78552324031" title="Function that the embed:: library uses to copy memory.">embed::memcpy</a></code> and <code><a class="el" href="#a6263c5b80970cfebe199a039d85eebca" title="Function that the embed library uses to copy memory.">embed::async_memcpy</a></code> function pinters to overload it with your custom copy implementation, that for example uses a direct memory access controller (DMA).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination to which <code>count</code> many bytes will be written </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source from which <code>count</code> many bytes will be read </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62b2bd334fe44c7c8bf1f710ff0c2ce9" name="a62b2bd334fe44c7c8bf1f710ff0c2ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b2bd334fe44c7c8bf1f710ff0c2ce9">&#9670;&#160;</a></span>add_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::add_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d46/classembed_1_1_co_task.html">CoTask</a> *</td>          <td class="paramname"><span class="paramname"><em>task</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab10e9de89496c8c5b3d7ed2f478dcb92" name="ab10e9de89496c8c5b3d7ed2f478dcb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10e9de89496c8c5b3d7ed2f478dcb92">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if all values from the <code>list</code> (converted to bool) are <code>true</code> </p>

</div>
</div>
<a id="ac542a787aaa82b103fbb0de3d82b7850" name="ac542a787aaa82b103fbb0de3d82b7850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac542a787aaa82b103fbb0de3d82b7850">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if any (aka. at least one) values from the <code>list</code> (converted to bool) are <code>true</code> </p>

</div>
</div>
<a id="a3dfef4733fb9c8869140d4acb0252628" name="a3dfef4733fb9c8869140d4acb0252628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfef4733fb9c8869140d4acb0252628">&#9670;&#160;</a></span>async_memcpy_s() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::async_memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1978f432d556a2358f47ef336c63c4fb" name="a1978f432d556a2358f47ef336c63c4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1978f432d556a2358f47ef336c63c4fb">&#9670;&#160;</a></span>async_memcpy_s() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::async_memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>destFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>destLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>sourceFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>sourceLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbecfc83a78e298a7740b8c6c87cdd25" name="acbecfc83a78e298a7740b8c6c87cdd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbecfc83a78e298a7740b8c6c87cdd25">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::compare </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const T1 &amp;l, const T2 &amp;r)&gt;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>Default</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compares the ranges given by closed-open iterators </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>value type of the left ranges </td></tr>
    <tr><td class="paramname">T2</td><td>value type of the right ranges </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">afirst</td><td>start iterator of the left range </td></tr>
    <tr><td class="paramname">alast</td><td>end iterator of the left range </td></tr>
    <tr><td class="paramname">bfirst</td><td>start iterator of the right range </td></tr>
    <tr><td class="paramname">blast</td><td>end iterator of the right range </td></tr>
    <tr><td class="paramname">compare</td><td>a function that compares them - the function returns true if <code>compare</code> is true for all elements </td></tr>
    <tr><td class="paramname">Default</td><td>the default value that should be returned in case the ranges do not have the same number of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the default if the ranges do not have the same size. if they have the same size returns true if the compare function evalues true for all elements </dd></dl>

</div>
</div>
<a id="a94940e93c424da8f4b0832585c298e50" name="a94940e93c424da8f4b0832585c298e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94940e93c424da8f4b0832585c298e50">&#9670;&#160;</a></span>disable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::disable_interrupts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that is used to disable the interrupts. </p>
<p>This function disables interrupts in a thread safe manner. It will make sure that in a series of calls to <code><a class="el" href="#a94940e93c424da8f4b0832585c298e50" title="Function that is used to disable the interrupts.">disable_interrupts()</a></code> and <code><a class="el" href="#af20267fb3069e1a33fc6967d3d1fd6bc" title="Function pointer that is used to enable the interrupts.">enable_interrupts()</a></code> only the first will disable it and the last will enable it.</p>
<p>It will internally call the user overloadable weak function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a17932d4994263ab57d2168ba020ac414">disable_interrupts_command</a>()</div>
<div class="ttc" id="anamespaceembed_html_a17932d4994263ab57d2168ba020ac414"><div class="ttname"><a href="#a17932d4994263ab57d2168ba020ac414">embed::disable_interrupts_command</a></div><div class="ttdeci">EMBED_WEAK void disable_interrupts_command()</div><div class="ttdoc">Weak, user overloadable function that provides the command to disable interrupts.</div><div class="ttdef"><b>Definition</b> interrupts.cpp:107</div></div>
</div><!-- fragment --><p>If you are working on a single core machine without peremption, consider defining <code>EMBED_SINGLE_CORE</code> for a simplified and faster version. </p>

</div>
</div>
<a id="a17932d4994263ab57d2168ba020ac414" name="a17932d4994263ab57d2168ba020ac414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17932d4994263ab57d2168ba020ac414">&#9670;&#160;</a></span>disable_interrupts_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc9/definitions_8hpp.html#a08b252cdce9dc7cc5979e26c8931af0b">EMBED_WEAK</a> void embed::disable_interrupts_command </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weak, user overloadable function that provides the command to disable interrupts. </p>

</div>
</div>
<a id="af20267fb3069e1a33fc6967d3d1fd6bc" name="af20267fb3069e1a33fc6967d3d1fd6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20267fb3069e1a33fc6967d3d1fd6bc">&#9670;&#160;</a></span>enable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::enable_interrupts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function pointer that is used to enable the interrupts. </p>
<p>This function enables interrupts in a thread safe manner. It will make sure that in a series of calls to <code><a class="el" href="#a94940e93c424da8f4b0832585c298e50" title="Function that is used to disable the interrupts.">disable_interrupts()</a></code> and <code><a class="el" href="#af20267fb3069e1a33fc6967d3d1fd6bc" title="Function pointer that is used to enable the interrupts.">enable_interrupts()</a></code> only the first will disable it and the last will enable it.</p>
<p>It will internally call the user overloadable weak function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#ad82d3d8858d1b2aa04e2bfc7f11ba971">enable_interrupts_command</a>()</div>
<div class="ttc" id="anamespaceembed_html_ad82d3d8858d1b2aa04e2bfc7f11ba971"><div class="ttname"><a href="#ad82d3d8858d1b2aa04e2bfc7f11ba971">embed::enable_interrupts_command</a></div><div class="ttdeci">EMBED_WEAK void enable_interrupts_command()</div><div class="ttdoc">Weak, user overloadable function that probides the command to enable interrupts.</div><div class="ttdef"><b>Definition</b> interrupts.cpp:112</div></div>
</div><!-- fragment --><p>If you are working on a single core machine without peremption, consider defining <code>EMBED_SINGLE_CORE</code> for a simplified and faster version. </p>

</div>
</div>
<a id="ad82d3d8858d1b2aa04e2bfc7f11ba971" name="ad82d3d8858d1b2aa04e2bfc7f11ba971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82d3d8858d1b2aa04e2bfc7f11ba971">&#9670;&#160;</a></span>enable_interrupts_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc9/definitions_8hpp.html#a08b252cdce9dc7cc5979e26c8931af0b">EMBED_WEAK</a> void embed::enable_interrupts_command </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weak, user overloadable function that probides the command to enable interrupts. </p>

</div>
</div>
<a id="aa1be0779e7c838af9fabe0cf2d3bd34b" name="aa1be0779e7c838af9fabe0cf2d3bd34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1be0779e7c838af9fabe0cf2d3bd34b">&#9670;&#160;</a></span>endl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::endl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a new line character to the stream followed by a call to <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html#acd3cef8a72e71ea2d8d15a1275cbb480" title="Overload this method to force flush the buffer.">OStream::flush()</a> </p>
<p>Calls <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html#aa7b871a33acbd8711a2dda86206b2e13" title="Prints a new line character followed by a call flush()">OStream::endl()</a>. Uses the new line character set by the stream with OStream::new_line_char(). </p>

</div>
</div>
<a id="a69d18a5db91c6ea30e309aab03468637" name="a69d18a5db91c6ea30e309aab03468637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d18a5db91c6ea30e309aab03468637">&#9670;&#160;</a></span>equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both containers have the same number of and value of elements </p>

</div>
</div>
<a id="a8d24cf724b88db46b5d08e62c61535c2" name="a8d24cf724b88db46b5d08e62c61535c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d24cf724b88db46b5d08e62c61535c2">&#9670;&#160;</a></span>equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::equal </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if both ranges are equal in value and count </p>

</div>
</div>
<a id="a849324c8a3c7cfafacc495323a2a2386" name="a849324c8a3c7cfafacc495323a2a2386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849324c8a3c7cfafacc495323a2a2386">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a new line character to the stream. </p>
<p>Calls <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html#acd3cef8a72e71ea2d8d15a1275cbb480" title="Overload this method to force flush the buffer.">OStream::flush()</a>. </p>

</div>
</div>
<a id="accfd2376bed93325057bafd88789b98f" name="accfd2376bed93325057bafd88789b98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfd2376bed93325057bafd88789b98f">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N, class Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto embed::for_each </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff4f6a3d44543a027f1e2c082f441126" name="aff4f6a3d44543a027f1e2c082f441126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4f6a3d44543a027f1e2c082f441126">&#9670;&#160;</a></span>frexp10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float embed::frexp10 </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>exp10_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78ee8549b969e0ec1355b46484a30ee5" name="a78ee8549b969e0ec1355b46484a30ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ee8549b969e0ec1355b46484a30ee5">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) embed::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">embed::FuturePromisePair</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77a7260de3819087ef35ac07d871874e" name="a77a7260de3819087ef35ac07d871874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a7260de3819087ef35ac07d871874e">&#9670;&#160;</a></span>greater() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both containers have the same number of elements and the left one has point-wise greater ones for all entries </p>

</div>
</div>
<a id="aef275b91927e0abdc24e71807be5a539" name="aef275b91927e0abdc24e71807be5a539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef275b91927e0abdc24e71807be5a539">&#9670;&#160;</a></span>greater() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::greater </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the ranges are equal in count and the left ranges value are all greater than the right ones </p>

</div>
</div>
<a id="a40149c55b3d976921a67ebbb9a811b81" name="a40149c55b3d976921a67ebbb9a811b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40149c55b3d976921a67ebbb9a811b81">&#9670;&#160;</a></span>greater_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::greater_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both containers have the same number of elements and the left one has point-wise greater or equal ones for all entries </p>

</div>
</div>
<a id="ab1a3568d020673576be1f5e80c3102eb" name="ab1a3568d020673576be1f5e80c3102eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a3568d020673576be1f5e80c3102eb">&#9670;&#160;</a></span>greater_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::greater_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the ranges are equal in count and the left ranges value are all greater or equal to the right ones </p>

</div>
</div>
<a id="a2c99f01dff3225a8a8ea946efb70926e" name="a2c99f01dff3225a8a8ea946efb70926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c99f01dff3225a8a8ea946efb70926e">&#9670;&#160;</a></span>is_inf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::is_inf </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0dbc4d9e568dd8f49796585866d083d" name="af0dbc4d9e568dd8f49796585866d083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dbc4d9e568dd8f49796585866d083d">&#9670;&#160;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::is_nan </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac368b64120fc9895d53b20d4d57335f" name="aac368b64120fc9895d53b20d4d57335f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac368b64120fc9895d53b20d4d57335f">&#9670;&#160;</a></span>is_ninf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::is_ninf </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd776e8fcb055db77d25a5378dd14e16" name="afd776e8fcb055db77d25a5378dd14e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd776e8fcb055db77d25a5378dd14e16">&#9670;&#160;</a></span>is_pinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::is_pinf </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c6c8c4fba4c9f05ce9fe26f779dd922" name="a5c6c8c4fba4c9f05ce9fe26f779dd922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6c8c4fba4c9f05ce9fe26f779dd922">&#9670;&#160;</a></span>less() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both containers have the same number of elements and the left one has point-wise lesser ones for all entries </p>

</div>
</div>
<a id="a0b39257b05de550d42394d01053915d3" name="a0b39257b05de550d42394d01053915d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b39257b05de550d42394d01053915d3">&#9670;&#160;</a></span>less() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::less </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the ranges are equal in count and the left ranges value are all smaller than the right ones </p>

</div>
</div>
<a id="a9953b4117f8559d68e0e132730b7dd9a" name="a9953b4117f8559d68e0e132730b7dd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9953b4117f8559d68e0e132730b7dd9a">&#9670;&#160;</a></span>less_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::less_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both containers have the same number of elements and the left one has point-wise lesser or equal ones for all entries </p>

</div>
</div>
<a id="a91a96821fa6772092d333de442e2afd4" name="a91a96821fa6772092d333de442e2afd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a96821fa6772092d333de442e2afd4">&#9670;&#160;</a></span>less_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::less_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the ranges are equal in count and the left ranges value are all less or equal to the right ones </p>

</div>
</div>
<a id="aec82ecae8adedfd3652fdad9835931c7" name="aec82ecae8adedfd3652fdad9835931c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec82ecae8adedfd3652fdad9835931c7">&#9670;&#160;</a></span>make_future_promise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a>&lt; T &gt; embed::make_future_promise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a linked future promise pair </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> [future, promise] = <a class="code hl_function" href="#aec82ecae8adedfd3652fdad9835931c7">make_future_promise&lt;int&gt;</a>();</div>
<div class="ttc" id="anamespaceembed_html_aec82ecae8adedfd3652fdad9835931c7"><div class="ttname"><a href="#aec82ecae8adedfd3652fdad9835931c7">embed::make_future_promise</a></div><div class="ttdeci">FuturePromisePair&lt; T &gt; make_future_promise()</div><div class="ttdoc">creates a linked future promise pair</div><div class="ttdef"><b>Definition</b> Future.hpp:788</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type that is being promised by the promise and awaited by the future </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linked <code><a class="el" href="../../d2/d3b/structembed_1_1_future_promise_pair.html">FuturePromisePair</a></code> <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> promise pair </dd></dl>

</div>
</div>
<a id="a0aef787367fcd2d3d3bac830e61174c6" name="a0aef787367fcd2d3d3bac830e61174c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aef787367fcd2d3d3bac830e61174c6">&#9670;&#160;</a></span>memcpy_s() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>destSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sourceSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies from source to dest so that no more bytes than destSize or sourceSize are written </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>a pointer to the destination that data should be written to </td></tr>
    <tr><td class="paramname">destSize</td><td>The number of bytes that can be written to dest </td></tr>
    <tr><td class="paramname">source</td><td>a pointer to the source that data should be read from </td></tr>
    <tr><td class="paramname">sourceSize</td><td>The number of bytes that can be read from the source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a348183f304efebc2fa669e9e0edb1976" name="a348183f304efebc2fa669e9e0edb1976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348183f304efebc2fa669e9e0edb1976">&#9670;&#160;</a></span>memcpy_s() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>destFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>destLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>sourceFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>sourceLast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from source to dest, without leaving the closed open range [first, last) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destFirst</td><td>Pointer to the first byte that should be written to </td></tr>
    <tr><td class="paramname">destLast</td><td>Pointer past the last byte that should be written to </td></tr>
    <tr><td class="paramname">sourceFirst</td><td>Pointer to the first byte that should be read from </td></tr>
    <tr><td class="paramname">sourceLast</td><td>Pointer past the last byte that should be read from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a234c0b40a4641ebcd1ddb97909dd1468" name="a234c0b40a4641ebcd1ddb97909dd1468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234c0b40a4641ebcd1ddb97909dd1468">&#9670;&#160;</a></span>newl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embed::newl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a new line character to the stream. </p>
<p>Calls <a class="el" href="../../da/d0a/classembed_1_1_o_stream.html#ad03783a4eaa6c187b36630374fa03e14" title="Prints a new line character. Compared to endl(), this function does not call flush()">OStream::newl()</a>. Uses the new line character set by the stream with OStream::new_line_char(). </p>

</div>
</div>
<a id="af64914d60734da52ba7e9136c99ca519" name="af64914d60734da52ba7e9136c99ca519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64914d60734da52ba7e9136c99ca519">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::none </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if no values from the <code>list</code> (converted to bool) are <code>true</code> </p>

</div>
</div>
<a id="a23681fb86b52040ddd0eeeb839176eec" name="a23681fb86b52040ddd0eeeb839176eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23681fb86b52040ddd0eeeb839176eec">&#9670;&#160;</a></span>not_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::not_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T1, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T2, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns <code>true</code> if both containers do not have the same number of and value of elements </p>

</div>
</div>
<a id="ac224c65075595660c444f070fd93c0f9" name="ac224c65075595660c444f070fd93c0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac224c65075595660c444f070fd93c0f9">&#9670;&#160;</a></span>not_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::not_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>afirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 *</td>          <td class="paramname"><span class="paramname"><em>alast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>bfirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *</td>          <td class="paramname"><span class="paramname"><em>blast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the ranges are not equal in value nor count </p>

</div>
</div>
<a id="a29a518469216ea461af3ee417253e20a" name="a29a518469216ea461af3ee417253e20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a518469216ea461af3ee417253e20a">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise un-equal list of the left and right hand side </p>

</div>
</div>
<a id="ab0a32fb35743a20e943395b7819062bd" name="ab0a32fb35743a20e943395b7819062bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a32fb35743a20e943395b7819062bd">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise less list of the left and right hand side </p>

</div>
</div>
<a id="ac1bd68bda525710bbc6bb8790456bd6a" name="ac1bd68bda525710bbc6bb8790456bd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bd68bda525710bbc6bb8790456bd6a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default bool formating, uses the settings of the stream. </p>

</div>
</div>
<a id="a9ea3950d85e2687a040672c64da707ad" name="a9ea3950d85e2687a040672c64da707ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea3950d85e2687a040672c64da707ad">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a char to the stream. </p>

</div>
</div>
<a id="a612f772633b86468b9f21e296ee7b4c7" name="a612f772633b86468b9f21e296ee7b4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612f772633b86468b9f21e296ee7b4c7">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes a terminated c-style string to the stream </p>

</div>
</div>
<a id="ad866fb7cc44f6f1fa85fcb416676d05d" name="ad866fb7cc44f6f1fa85fcb416676d05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad866fb7cc44f6f1fa85fcb416676d05d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral UInt, CStdRatio Period = std::ratio&lt;1&gt;, UInt MaxTick = std::numeric_limits&lt;UInt&gt;::max()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a0223e2bd607a0788b0c7955a65dfe73f">Duration</a>&lt; UInt, Period, MaxTick &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>duration</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad062018b3e2ec5ee9102877c6132f5fc" name="ad062018b3e2ec5ee9102877c6132f5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad062018b3e2ec5ee9102877c6132f5fc">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d2f/classembed_1_1_exception.html">Exception</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa739db9084a3ca2490b87a922fd585f6" name="aa739db9084a3ca2490b87a922fd585f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa739db9084a3ca2490b87a922fd585f6">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d02/structembed_1_1_format_bool.html">FormatBool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a bool to the output stream and applies custom formating. </p>

</div>
</div>
<a id="ae653f2b9b9c8a42a244d7bb76cedb35d" name="ae653f2b9b9c8a42a244d7bb76cedb35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae653f2b9b9c8a42a244d7bb76cedb35d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d25/structembed_1_1_format_int.html">FormatInt</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fvalue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints integers to streams with a certain format. </p>

</div>
</div>
<a id="a0e30ea59b81aa27862451e84c9da3501" name="a0e30ea59b81aa27862451e84c9da3501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e30ea59b81aa27862451e84c9da3501">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d23/structembed_1_1_format_str.html">FormatStr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fstr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <code><a class="el" href="../../dc/d23/structembed_1_1_format_str.html" title="Formats a string and allows to pass an additional size parameter.">FormatStr</a></code> to the stream that allows to pass the string length in addition to the <code>const char*</code> type string. </p>

</div>
</div>
<a id="aa14d30c7afbdb340c36e85dbb0876e9b" name="aa14d30c7afbdb340c36e85dbb0876e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14d30c7afbdb340c36e85dbb0876e9b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int, typename std::enable_if&lt; std::is_integral&lt; Int &gt;::value, int &gt;::type = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf1fd5b05253b9d2742f1ae2dc74a36" name="abbf1fd5b05253b9d2742f1ae2dc74a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf1fd5b05253b9d2742f1ae2dc74a36">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints the array list to the output stream </p>

</div>
</div>
<a id="a7eb659d1ae70230815733bbf5adc92fc" name="a7eb659d1ae70230815733bbf5adc92fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb659d1ae70230815733bbf5adc92fc">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ce5bdc89df2cf8eca7fb6b325122c4b" name="a9ce5bdc89df2cf8eca7fb6b325122c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce5bdc89df2cf8eca7fb6b325122c4b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, std::unsigned_integral UInt = Clock::value_type, CStdRatio Period = Clock::period, UInt MaxTick = Clock::max_tick&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af176ead949b706e7d5afcb8ddb67b543">TimePoint</a>&lt; <a class="el" href="../../da/d86/structembed_1_1_clock.html">Clock</a>, UInt, Period, MaxTick &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d8afd0567c76141cbfd1fd2d9833ec3" name="a4d8afd0567c76141cbfd1fd2d9833ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8afd0567c76141cbfd1fd2d9833ec3">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae2cdc9f9929967b62dfcec7be0e6c2f1">Exit</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d648bf3139d52abbf1c5a3981fdf6b" name="a75d648bf3139d52abbf1c5a3981fdf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d648bf3139d52abbf1c5a3981fdf6b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float, typename std::enable_if&lt; std::is_floating_point&lt; Float &gt;::value, int &gt;::type = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5e984c6721dcdf20c2e831160b75484" name="af5e984c6721dcdf20c2e831160b75484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e984c6721dcdf20c2e831160b75484">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d05/structembed_1_1_format_float.html">FormatFloat</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41e8046410d09a4d314f1a58496ca15b" name="a41e8046410d09a4d314f1a58496ca15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e8046410d09a4d314f1a58496ca15b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::unsigned_integral UInt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d27/structembed_1_1_format_hex.html">FormatHex</a>&lt; UInt &gt;</td>          <td class="paramname"><span class="paramname"><em>hex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a820596136806116345e7b29ad64a06e6" name="a820596136806116345e7b29ad64a06e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820596136806116345e7b29ad64a06e6">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4636e466b73a553d3c87828d88bcac4b" name="a4636e466b73a553d3c87828d88bcac4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4636e466b73a553d3c87828d88bcac4b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaea56d0d8ed2777f351446d35730e484" name="aaea56d0d8ed2777f351446d35730e484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea56d0d8ed2777f351446d35730e484">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::minutes</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f31cf9cfc65dac727a6c8985677efc" name="a90f31cf9cfc65dac727a6c8985677efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f31cf9cfc65dac727a6c8985677efc">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::nanoseconds</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a591095b1cd7b3b24d84a7aec2074b7e8" name="a591095b1cd7b3b24d84a7aec2074b7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591095b1cd7b3b24d84a7aec2074b7e8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::seconds</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cb360b366a0f258534229ac0bf4cd94" name="a4cb360b366a0f258534229ac0bf4cd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb360b366a0f258534229ac0bf4cd94">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae55444c8c42d892d8dce9369bb61dcbf" name="ae55444c8c42d892d8dce9369bb61dcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55444c8c42d892d8dce9369bb61dcbf">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp; embed::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>function&#160;</em></span>)(<a class="el" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a> &amp;)&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a function with the stream as the argument. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="../../da/d0a/classembed_1_1_o_stream.html">OStream</a>&amp;){</div>
<div class="line">     <span class="comment">// do stuff</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">     stream &lt;&lt; function;</div>
<div class="line">     <span class="comment">// is equivalent to</span></div>
<div class="line">     function(stream)</div>
<div class="line">     </div>
<div class="line">     <span class="comment">// Intended usages:</span></div>
<div class="line">     <span class="keyword">using namespace </span><a class="code hl_namespace" href="../../da/d2e/namespaceembed.html">embed</a>;</div>
<div class="line">     stream &lt;&lt; <span class="stringliteral">&quot;This is followed by a new line&quot;</span> &lt;&lt; <a class="code hl_function" href="#a234c0b40a4641ebcd1ddb97909dd1468">newl</a>();</div>
<div class="line">     stream &lt;&lt; <span class="stringliteral">&quot;This line is flushed&quot;</span> &lt;&lt; <a class="code hl_function" href="#a849324c8a3c7cfafacc495323a2a2386">flush</a>();</div>
<div class="line">     stream &lt;&lt; <span class="stringliteral">&quot;This line is followed by a newline and flushed&quot;</span> &lt;&lt; <a class="code hl_function" href="#aa1be0779e7c838af9fabe0cf2d3bd34b">endl</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassembed_1_1_o_stream_html"><div class="ttname"><a href="../../da/d0a/classembed_1_1_o_stream.html">embed::OStream</a></div><div class="ttdoc">Abstract class for an output character stream that offers string and number formating.</div><div class="ttdef"><b>Definition</b> OStream.hpp:121</div></div>
<div class="ttc" id="anamespaceembed_html"><div class="ttname"><a href="../../da/d2e/namespaceembed.html">embed</a></div><div class="ttdef"><b>Definition</b> StaticArrayList.hpp:18</div></div>
<div class="ttc" id="anamespaceembed_html_a234c0b40a4641ebcd1ddb97909dd1468"><div class="ttname"><a href="#a234c0b40a4641ebcd1ddb97909dd1468">embed::newl</a></div><div class="ttdeci">void newl(OStream &amp;stream)</div><div class="ttdoc">Writes a new line character to the stream.</div><div class="ttdef"><b>Definition</b> OStream.hpp:179</div></div>
<div class="ttc" id="anamespaceembed_html_a849324c8a3c7cfafacc495323a2a2386"><div class="ttname"><a href="#a849324c8a3c7cfafacc495323a2a2386">embed::flush</a></div><div class="ttdeci">void flush(OStream &amp;stream)</div><div class="ttdoc">Writes a new line character to the stream.</div><div class="ttdef"><b>Definition</b> OStream.hpp:186</div></div>
<div class="ttc" id="anamespaceembed_html_aa1be0779e7c838af9fabe0cf2d3bd34b"><div class="ttname"><a href="#aa1be0779e7c838af9fabe0cf2d3bd34b">embed::endl</a></div><div class="ttdeci">void endl(OStream &amp;stream)</div><div class="ttdoc">Writes a new line character to the stream followed by a call to OStream::flush()</div><div class="ttdef"><b>Definition</b> OStream.hpp:194</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac63ab39fd8cb11e77a330ecc8eae0860" name="ac63ab39fd8cb11e77a330ecc8eae0860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63ab39fd8cb11e77a330ecc8eae0860">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise less equal list of the left and right hand side </p>

</div>
</div>
<a id="a9df64ddd14285cc7bb22ad03cc854c75" name="a9df64ddd14285cc7bb22ad03cc854c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df64ddd14285cc7bb22ad03cc854c75">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise equal list of the left and right hand side </p>

</div>
</div>
<a id="a1d482591de5501579e78035d23dae9ae" name="a1d482591de5501579e78035d23dae9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d482591de5501579e78035d23dae9ae">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise greater list of the left and right hand side </p>

</div>
</div>
<a id="a5eabb253b910b111803e29e877794cea" name="a5eabb253b910b111803e29e877794cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eabb253b910b111803e29e877794cea">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise greater equal list of the left and right hand side </p>

</div>
</div>
<a id="afb6b41076a22c83814f80942feeafc7b" name="afb6b41076a22c83814f80942feeafc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6b41076a22c83814f80942feeafc7b">&#9670;&#160;</a></span>point_wise_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; bool,(N1&lt; N2) ? N1 :N2 &gt; embed::point_wise_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const T &amp;l, const T &amp;r)&gt;</td>          <td class="paramname"><span class="paramname"><em>compare</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs a point wise comparison of the <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html" title="An array of contiguous memory which is statically allocated.">StaticArrayList</a> </p>
<dl class="section return"><dt>Returns</dt><dd>a boolean array list of the intersection of both lists with the result of the compare function </dd></dl>

</div>
</div>
<a id="ae579882a3c46704e6d11c01a1600ded5" name="ae579882a3c46704e6d11c01a1600ded5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae579882a3c46704e6d11c01a1600ded5">&#9670;&#160;</a></span>point_wise_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::point_wise_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise equal list of the left and right hand side </p>

</div>
</div>
<a id="ad3eb8a3e4437205b845b83edd917abe3" name="ad3eb8a3e4437205b845b83edd917abe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3eb8a3e4437205b845b83edd917abe3">&#9670;&#160;</a></span>point_wise_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::point_wise_greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise greater list of the left and right hand side </p>

</div>
</div>
<a id="a7a3378843465b983dc475d7feaeac9be" name="a7a3378843465b983dc475d7feaeac9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3378843465b983dc475d7feaeac9be">&#9670;&#160;</a></span>point_wise_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::point_wise_greater_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise greater equal list of the left and right hand side </p>

</div>
</div>
<a id="a05c4e078e1ec33336ee42c8cd2b24f29" name="a05c4e078e1ec33336ee42c8cd2b24f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c4e078e1ec33336ee42c8cd2b24f29">&#9670;&#160;</a></span>point_wise_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::point_wise_less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise less list of the left and right hand side </p>

</div>
</div>
<a id="a7469d1bbd5988ee0d2728f1de4dbca1a" name="a7469d1bbd5988ee0d2728f1de4dbca1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7469d1bbd5988ee0d2728f1de4dbca1a">&#9670;&#160;</a></span>point_wise_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::point_wise_less_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise less equal list of the left and right hand side </p>

</div>
</div>
<a id="a7869f20b360ae9917160184311b1f87d" name="a7869f20b360ae9917160184311b1f87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7869f20b360ae9917160184311b1f87d">&#9670;&#160;</a></span>point_wise_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t N1, std::size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto embed::point_wise_not_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/def/classembed_1_1_static_array_list.html">StaticArrayList</a>&lt; T, N2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the point wise un-equal list of the left and right hand side </p>

</div>
</div>
<a id="aa8910e9ca60ee5596303fc617b92fccd" name="aa8910e9ca60ee5596303fc617b92fccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8910e9ca60ee5596303fc617b92fccd">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int, typename std::enable_if&lt; std::is_integral&lt; Int &gt;::value, int &gt;::type = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int embed::pow </td>
          <td>(</td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a193507bf7b99407e04962553bbec80" name="a9a193507bf7b99407e04962553bbec80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a193507bf7b99407e04962553bbec80">&#9670;&#160;</a></span>print_failed_function_file_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::print_failed_function_file_line </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dda99a6f8c3a15238a76cf7426646b4" name="a6dda99a6f8c3a15238a76cf7426646b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda99a6f8c3a15238a76cf7426646b4">&#9670;&#160;</a></span>skalar_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::skalar_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a6f3965ef5e0ce426ebd7f87edf9306" name="a6a6f3965ef5e0ce426ebd7f87edf9306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6f3965ef5e0ce426ebd7f87edf9306">&#9670;&#160;</a></span>skalar_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::skalar_greater </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b24f542093876435e03886bd95d505c" name="a8b24f542093876435e03886bd95d505c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b24f542093876435e03886bd95d505c">&#9670;&#160;</a></span>skalar_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::skalar_greater_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a97347ee56fb5b9f79bb0148a6af579" name="a0a97347ee56fb5b9f79bb0148a6af579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a97347ee56fb5b9f79bb0148a6af579">&#9670;&#160;</a></span>skalar_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::skalar_less </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b88a131e36c38fbce4439ea392ca566" name="a4b88a131e36c38fbce4439ea392ca566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b88a131e36c38fbce4439ea392ca566">&#9670;&#160;</a></span>skalar_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::skalar_less_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8908ffebee1acb8f00dce51af1244f0" name="af8908ffebee1acb8f00dce51af1244f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8908ffebee1acb8f00dce51af1244f0">&#9670;&#160;</a></span>skalar_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::skalar_not_equal </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae443a3070e85e0878e665ccf0d73f9d1" name="ae443a3070e85e0878e665ccf0d73f9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae443a3070e85e0878e665ccf0d73f9d1">&#9670;&#160;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::spin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30769c05e8184748d55f9ed70eb393cc" name="a30769c05e8184748d55f9ed70eb393cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30769c05e8184748d55f9ed70eb393cc">&#9670;&#160;</a></span>StaticArrayList_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::StaticArrayList_test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f47d782f80fabf223abf14752f6fb3d" name="a5f47d782f80fabf223abf14752f6fb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47d782f80fabf223abf14752f6fb3d">&#9670;&#160;</a></span>str_add_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * embed::str_add_float </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d05/structembed_1_1_format_float.html">FormatFloat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b921f60de08b5ce3af95a2a78e1618d" name="a5b921f60de08b5ce3af95a2a78e1618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b921f60de08b5ce3af95a2a78e1618d">&#9670;&#160;</a></span>str_add_sint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * embed::str_add_sint </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d25/structembed_1_1_format_int.html#aba93e6faa9c923ded7675fa6ae624a72">FormatInt::value_type</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dba/structembed_1_1str__add__uint__params.html">str_add_uint_params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae54c87644e42197a01ceb09991ff8979" name="ae54c87644e42197a01ceb09991ff8979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54c87644e42197a01ceb09991ff8979">&#9670;&#160;</a></span>str_add_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * embed::str_add_uint </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::make_unsigned_t&lt; <a class="el" href="../../d7/d25/structembed_1_1_format_int.html#aba93e6faa9c923ded7675fa6ae624a72">FormatInt::value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dba/structembed_1_1str__add__uint__params.html">str_add_uint_params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8e9c37cca170435a19572f0d4e78e3a" name="aa8e9c37cca170435a19572f0d4e78e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e9c37cca170435a19572f0d4e78e3a">&#9670;&#160;</a></span>string_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t embed::string_length </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the length of a terminated c-style string </p>

</div>
</div>
<a id="a3915dc5b7472a01c0c6a9ac77755c8f8" name="a3915dc5b7472a01c0c6a9ac77755c8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3915dc5b7472a01c0c6a9ac77755c8f8">&#9670;&#160;</a></span>TEST_BINARY_OPERATOR_print_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_BINARY_OPERATOR_print_1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74f2e8b6b26ac401a1fcf9790cf170ef" name="a74f2e8b6b26ac401a1fcf9790cf170ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f2e8b6b26ac401a1fcf9790cf170ef">&#9670;&#160;</a></span>TEST_BINARY_OPERATOR_print_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, class R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_BINARY_OPERATOR_print_2 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3ddba714d37caded1c35736a02bacf9" name="ad3ddba714d37caded1c35736a02bacf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ddba714d37caded1c35736a02bacf9">&#9670;&#160;</a></span>TEST_ERROR_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_ERROR_print </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2417f212fa0f80e6b81f7d9270959496" name="a2417f212fa0f80e6b81f7d9270959496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2417f212fa0f80e6b81f7d9270959496">&#9670;&#160;</a></span>TEST_FALSE_print_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_FALSE_print_1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cf709b040cc89ae4be7157b18c22686" name="a5cf709b040cc89ae4be7157b18c22686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf709b040cc89ae4be7157b18c22686">&#9670;&#160;</a></span>TEST_FALSE_print_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_FALSE_print_2 </td>
          <td>(</td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af36ab1e1233cdbe06f6f3c85c4306e8c" name="af36ab1e1233cdbe06f6f3c85c4306e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36ab1e1233cdbe06f6f3c85c4306e8c">&#9670;&#160;</a></span>TEST_FUNC2_print_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_FUNC2_print_1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>test_func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adef5615d55f198e96559f877f447f04d" name="adef5615d55f198e96559f877f447f04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef5615d55f198e96559f877f447f04d">&#9670;&#160;</a></span>TEST_FUNC2_print_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, class R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_FUNC2_print_2 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>test_func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90bbbc388849cd0a33bf019eba6d4195" name="a90bbbc388849cd0a33bf019eba6d4195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bbbc388849cd0a33bf019eba6d4195">&#9670;&#160;</a></span>TEST_FUNC_print_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_FUNC_print_1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>test_func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54b4b90d82c02e85d9cf8799d56572ba" name="a54b4b90d82c02e85d9cf8799d56572ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b4b90d82c02e85d9cf8799d56572ba">&#9670;&#160;</a></span>TEST_FUNC_print_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_FUNC_print_2 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>test_func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcf4b09069973db1435ed1a7e376998f" name="abcf4b09069973db1435ed1a7e376998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf4b09069973db1435ed1a7e376998f">&#9670;&#160;</a></span>TEST_NOT_BINARY_OPERATOR_print_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_NOT_BINARY_OPERATOR_print_1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs_str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8a4e6880e0a5dbd26be6b864c4c394a" name="ab8a4e6880e0a5dbd26be6b864c4c394a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a4e6880e0a5dbd26be6b864c4c394a">&#9670;&#160;</a></span>TEST_NOT_BINARY_OPERATOR_print_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2, class R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_NOT_BINARY_OPERATOR_print_2 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a843685ca669191c0afc770417808951e" name="a843685ca669191c0afc770417808951e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843685ca669191c0afc770417808951e">&#9670;&#160;</a></span>TEST_TRUE_print_1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_TRUE_print_1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>signature</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7bfba877881d87f939c2604260c9713" name="af7bfba877881d87f939c2604260c9713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bfba877881d87f939c2604260c9713">&#9670;&#160;</a></span>TEST_TRUE_print_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embed::TEST_TRUE_print_2 </td>
          <td>(</td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3e0c5bef22c932ba22122839e2dff182" name="a3e0c5bef22c932ba22122839e2dff182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0c5bef22c932ba22122839e2dff182">&#9670;&#160;</a></span>_irq_disable_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;uint32_t&gt; embed::_irq_disable_count {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6263c5b80970cfebe199a039d85eebca" name="a6263c5b80970cfebe199a039d85eebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6263c5b80970cfebe199a039d85eebca">&#9670;&#160;</a></span>async_memcpy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* embed::async_memcpy)(void *dest, const void *source, size_t count, <a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt; promise) </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dd8/classembed_1_1_promise.html">Promise</a>&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span>&#160;) = <a class="el" href="#a704b9edb4fe2c28190616bdc7d71861d">_async_memcpy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that the embed library uses to copy memory. </p>
<p>The expected behaviour of memcpy is to copy count many bytes from source to dest in a non-blocking behaviour, aka. the function returns immediately after it has beed called which might happen before the copy finished.</p>
<p>This function pointer can be overloaded by the user for a concrete implementation that uses hardware acceleration, like f.e. a DMA controller that can copy data independently of the main prozessing thread.</p>
<p>Note: the default implementation is a blocking one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination to which <code>count</code> many bytes will be written </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source from which <code>count</code> many bytes will be read </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be copied </td></tr>
    <tr><td class="paramname">promise</td><td>A promise of a future result derived from a <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> type. So: pass a <a class="el" href="../../d8/d8c/classembed_1_1_future.html" title="Future and Promise pairs are used to synchronise values between asynchronous tasks.">Future</a> in here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a920dea94b29d748d0759ba99100b3a98" name="a920dea94b29d748d0759ba99100b3a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920dea94b29d748d0759ba99100b3a98">&#9670;&#160;</a></span>cerr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a> embed::cerr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0d6d4fa59dda37fb0bc6611627faa99" name="ac0d6d4fa59dda37fb0bc6611627faa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d6d4fa59dda37fb0bc6611627faa99">&#9670;&#160;</a></span>clog</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a> embed::clog</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12dcf29ad44042bbb681118a6c6fe885" name="a12dcf29ad44042bbb681118a6c6fe885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dcf29ad44042bbb681118a6c6fe885">&#9670;&#160;</a></span>coroutine_frame_allocator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pmr::memory_resource* embed::coroutine_frame_allocator = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b0196bffb98599840f820f09d867d7b" name="a2b0196bffb98599840f820f09d867d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0196bffb98599840f820f09d867d7b">&#9670;&#160;</a></span>CoTask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="../../dd/d78/classembed_1_1_i_scheduler.html">embed::IScheduler</a> embed::CoTask</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09b081abf25eac7c5df285045f3baa3a" name="a09b081abf25eac7c5df285045f3baa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b081abf25eac7c5df285045f3baa3a">&#9670;&#160;</a></span>cout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd5/structembed_1_1_o_stream_ref.html">OStreamRef</a> embed::cout</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a470bd266c8aae5c833cb5e3dc2ab07c9" name="a470bd266c8aae5c833cb5e3dc2ab07c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470bd266c8aae5c833cb5e3dc2ab07c9">&#9670;&#160;</a></span>expected_false_but</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* embed::expected_false_but = &quot; expected `false` but: `&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca1207d2a54eaeadbbc382caa0ee84a5" name="aca1207d2a54eaeadbbc382caa0ee84a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1207d2a54eaeadbbc382caa0ee84a5">&#9670;&#160;</a></span>expected_true_but</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* embed::expected_true_but = &quot; expected `true` but: `&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30cab50e4b835dc811b9cb686b41bbb4" name="a30cab50e4b835dc811b9cb686b41bbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cab50e4b835dc811b9cb686b41bbb4">&#9670;&#160;</a></span>indented_arrow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* embed::indented_arrow = &quot; --&gt; `&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6110642d9057733c6e33a62b37d6a0be" name="a6110642d9057733c6e33a62b37d6a0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6110642d9057733c6e33a62b37d6a0be">&#9670;&#160;</a></span>is_std_ratio_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool embed::is_std_ratio_v = <a class="el" href="../../d5/d2d/structembed_1_1is__std__ratio.html">is_std_ratio</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afca9b6603fe5654bfda9f78552324031" name="afca9b6603fe5654bfda9f78552324031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca9b6603fe5654bfda9f78552324031">&#9670;&#160;</a></span>memcpy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* embed::memcpy)(void *dest, const void *source, size_t count) </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) = <a class="el" href="#aebe0ff1b58799ddf5953a9f0ab47cfc1">_memcpy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that the embed:: library uses to copy memory. </p>
<p>The expected behaviour of memcpy is to copy count many bytes from source to dest in a blocking behaviour, aka. the function returns once the copy has completed.</p>
<p>This function pointer can be overloaded by the user for a concrete implementation that uses hardware acceleration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination to which <code>count</code> many bytes will be written </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the source from which <code>count</code> many bytes will be read </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes that will be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53eb85d54a5d35d962cd15d7e334de96" name="a53eb85d54a5d35d962cd15d7e334de96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eb85d54a5d35d962cd15d7e334de96">&#9670;&#160;</a></span>task_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="../../dd/d78/classembed_1_1_i_scheduler.html">embed::IScheduler</a> embed::task_list</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../da/d2e/namespaceembed.html">embed</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
